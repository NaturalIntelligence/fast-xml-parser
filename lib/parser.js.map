{"version":3,"sources":["webpack://parser/webpack/universalModuleDefinition","webpack://parser/webpack/bootstrap","webpack://parser/./src/util.js","webpack://parser/./src/xmlstr2xmlnode.js","webpack://parser/./src/parser.js","webpack://parser/./src/node2json.js","webpack://parser/./src/xmlNode.js","webpack://parser/./src/nimndata.js","webpack://parser/./src/node2json_str.js","webpack://parser/./src/validator.js","webpack://parser/./src/json2xml.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","doesMatch","string","regex","match","exec","isExist","v","isEmptyObject","obj","keys","length","merge","target","a","len","getValue","buildOptions","options","defaultOptions","props","newOptions","undefined","doesNotMatch","getAllMatches","matches","allmatches","index","push","util","xmlNode","TagType","OPENING","CLOSING","SELF","CDATA","regx","attributeNamePrefix","attrNodeName","textNodeName","ignoreAttributes","ignoreNameSpace","allowBooleanAttributes","parseNodeValue","parseAttributeValue","arrayMode","trimValues","cdataTagName","cdataPositionChar","localeRange","tagValueProcessor","attrValueProcessor","processTagValue","val","trim","parseValue","parseTrueNumberOnly","checkForTagType","substr","resolveNameSpace","tagname","tags","split","prefix","charAt","shouldParse","parsed","isNaN","indexOf","parseInt","parseFloat","String","attrsRegx","RegExp","buildAttributesMap","attrStr","replace","attrs","attrName","attrCollection","getTraversalObj","xmlData","xmlObj","currentNode","tagsRegx","tag","nextTag","tagType","parent","childNode","attrsMap","addChild","nodeToJson","xmlToNodeobj","x2xmlnode","parse","convertToJson","convertTonimn","convert2nimn","convertToJsonString","validate","j2xParser","parseToNimn","schema","node","jObj","child","this","char","fromCharCode","chars","nilChar","missingChar","nilPremitive","missingPremitive","emptyChar","emptyValue","boundryChar","objStart","arrStart","arrayEnd","charsArr","_e","e_schema","hasValidData","hasData","str","Array","isArray","itemSchema","arr_len","arr_i","processValue","isAppChar","ch","x2j","_cToJsonStr","level","stringval","indentBy","readPI","start","err","code","msg","readCommentAndCDATA","angleBracketsCount","tagFound","regxAttrName","regxTagName","closingTag","tagName","substring","validateTagName","result","readAttributeStr","isValid","validateAttributeString","otg","pop","JSON","stringify","doubleQuote","singleQuote","startChar","validAttrStrRegxp","attrNames","validateAttrName","format","supressEmptyNode","inlineEmptyNode","Parser","isAttribute","attrPrefixLen","isCDATA","replaceCDATAstr","replaceCDATAarr","indentate","tagEndChar","newLine","buildTextNode","buildEmptyTextNode","buildObjNode","buildEmptyObjNode","buildTextValNode","buildObjectNode","cdata","join","includes","tagValue","repeat","startsWith","j2x","attr","arrLen","j","item","Ks","L"],"mappings":"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","file":"./lib/parser.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"parser\"] = factory();\n\telse\n\t\troot[\"parser\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","\"use strict\";\n\nconst getAllMatches = function(string, regex) {\n    const matches = [];\n    let match = regex.exec(string);\n    while (match) {\n        const allmatches = [];\n        const len = match.length;\n        for (let index = 0; index < len; index++) {\n            allmatches.push(match[index]);\n        }\n        matches.push(allmatches);\n        match = regex.exec(string);\n    }\n    return matches;\n};\n\nconst doesMatch = function(string, regex) {\n    const match = regex.exec(string);\n    return !(match === null || typeof match === \"undefined\");\n};\n\nconst doesNotMatch = function(string, regex) {\n    return !doesMatch(string, regex);\n};\n\nexports.isExist = function(v) {\n    return typeof v !== \"undefined\";\n};\n\nexports.isEmptyObject = function(obj) {\n    return Object.keys(obj).length === 0;\n};\n\n/**\n * Copy all the properties of a into b.\n * @param {*} target\n * @param {*} a\n */\nexports.merge = function(target, a) {\n    if (a) {\n        const keys = Object.keys(a); // will return an array of own properties\n        const len = keys.length; //don't make it inline\n        for (let i = 0; i < len; i++) {\n            target[keys[i]] = a[keys[i]];\n        }\n    }\n};\n/* exports.merge =function (b,a){\n  return Object.assign(b,a);\n} */\n\nexports.getValue = function(v) {\n    if (exports.isExist(v)) {\n        return v;\n    } else {\n        return \"\";\n    }\n};\n\n// const fakeCall = function(a) {return a;};\n// const fakeCallNoReturn = function() {};\n\nexports.buildOptions = function(options,defaultOptions,props) {\n    var newOptions = {};\n    if (!options) {\n        return defaultOptions; //if there are not options\n    }\n\n    for (let i = 0; i < props.length; i++) {\n        if ( options[props[i]] !== undefined) {\n            newOptions[props[i]] = options[props[i]];\n        }else{\n            newOptions[props[i]] = defaultOptions[props[i]];\n        }\n    }\n    return newOptions;\n};\n\nexports.doesMatch = doesMatch;\nexports.doesNotMatch = doesNotMatch;\nexports.getAllMatches = getAllMatches;\n","\"use strict\";\n\nconst util = require(\"./util\");\nconst buildOptions = require(\"./util\").buildOptions;\nconst xmlNode = require(\"./xmlNode\");\nconst TagType = {\"OPENING\": 1, \"CLOSING\": 2, \"SELF\": 3, \"CDATA\": 4};\nlet regx = \"<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|(([\\\\w:\\\\-._]*:)?([\\\\w:\\\\-._]+))([^>]*)>|((\\\\/)(([\\\\w:\\\\-._]*:)?([\\\\w:\\\\-._]+))\\\\s*>))([^<]*)\";\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\n//treat cdata as a tag\n\nconst defaultOptions = {\n    attributeNamePrefix:    \"@_\",\n    attrNodeName:           false,\n    textNodeName:           \"#text\",\n    ignoreAttributes:       true,\n    ignoreNameSpace:        false,\n    allowBooleanAttributes: false,         //a tag can have attributes without any value\n    //ignoreRootElement : false,\n    parseNodeValue:         true,\n    parseAttributeValue:    false,\n    arrayMode:              false,\n    trimValues:             true,                                //Trim string values of tag and attributes\n    cdataTagName:           false,\n    cdataPositionChar:      \"\\\\c\",\n    localeRange:            \"\",\n    tagValueProcessor: function(a) {return a},\n    attrValueProcessor: function(a) {return a}\n    //decodeStrict: false,\n};\n\nexports.defaultOptions = defaultOptions;\n\nconst props = [\"attributeNamePrefix\", \"attrNodeName\", \"textNodeName\", \"ignoreAttributes\", \"ignoreNameSpace\", \"allowBooleanAttributes\", \"parseNodeValue\", \"parseAttributeValue\", \"arrayMode\", \"trimValues\", \"cdataTagName\", \"cdataPositionChar\", \"localeRange\", \"tagValueProcessor\", \"attrValueProcessor\", \"parseTrueNumberOnly\"];\nexports.props = props;\n\nconst getTraversalObj = function(xmlData, options) {\n    options = buildOptions(options,defaultOptions,props);\n    //xmlData = xmlData.replace(/\\r?\\n/g, \" \");//make it single line\n    xmlData = xmlData.replace(/<!--[\\s\\S]*?-->/g, \"\");//Remove  comments\n\n    const xmlObj = new xmlNode(\"!xml\");\n    let currentNode = xmlObj;\n\n    regx = regx.replace(/\\[\\\\w/g, \"[\" + options.localeRange + \"\\\\w\");\n    const tagsRegx = new RegExp(regx, \"g\");\n    let tag = tagsRegx.exec(xmlData);\n    let nextTag = tagsRegx.exec(xmlData);\n    while (tag) {\n        const tagType = checkForTagType(tag);\n\n        if (tagType === TagType.CLOSING) {\n            //add parsed data to parent node\n            if (currentNode.parent && tag[14]) {\n                currentNode.parent.val = util.getValue(currentNode.parent.val) + \"\" + processTagValue(tag[14], options);\n            }\n\n            currentNode = currentNode.parent;\n        } else if (tagType === TagType.CDATA) {\n            if (options.cdataTagName) {\n                //add cdata node\n                const childNode = new xmlNode(options.cdataTagName, currentNode, tag[3]);\n                childNode.attrsMap = buildAttributesMap(tag[8], options);\n                currentNode.addChild(childNode);\n                //for backtracking\n                currentNode.val = util.getValue(currentNode.val) + options.cdataPositionChar;\n                //add rest value to parent node\n                if (tag[14]) {\n                    currentNode.val += processTagValue(tag[14], options);\n                }\n            } else {\n                currentNode.val = (currentNode.val || \"\") + (tag[3] || \"\") + processTagValue(tag[14], options);\n            }\n        } else if (tagType === TagType.SELF) {\n            if (currentNode && tag[14]) {\n                currentNode.val = util.getValue(currentNode.val) + \"\" + processTagValue(tag[14], options);\n            }\n\n            const childNode = new xmlNode(options.ignoreNameSpace ? tag[7] : tag[5], currentNode, \"\");\n            if (tag[8] && tag[8].length > 1) {\n                tag[8] = tag[8].substr(0, tag[8].length - 1);\n            }\n            childNode.attrsMap = buildAttributesMap(tag[8], options);\n            currentNode.addChild(childNode);\n        } else {//TagType.OPENING\n            const childNode = new xmlNode(options.ignoreNameSpace ? tag[7] : tag[5], currentNode, processTagValue(tag[14], options));\n            childNode.attrsMap = buildAttributesMap(tag[8], options);\n            currentNode.addChild(childNode);\n            currentNode = childNode;\n        }\n\n        tag = nextTag;\n        nextTag = tagsRegx.exec(xmlData);\n    }\n\n    return xmlObj;\n};\n\nfunction processTagValue(val, options) {\n    if (val) {\n        if (options.trimValues) {\n            val = val.trim();\n        }\n        val = options.tagValueProcessor(val);\n        val = parseValue(val, options.parseNodeValue, options.parseTrueNumberOnly);\n    }\n\n    return val;\n}\n\nfunction checkForTagType(match) {\n    if (match[4] === \"]]>\") {\n        return TagType.CDATA;\n    } else if (match[10] === \"/\") {\n        return TagType.CLOSING;\n    } else if (typeof match[8] !== \"undefined\" && match[8].substr(match[8].length - 1) === \"/\") {\n        return TagType.SELF;\n    } else {\n        return TagType.OPENING;\n    }\n}\n\nfunction resolveNameSpace(tagname, options) {\n    if (options.ignoreNameSpace) {\n        const tags = tagname.split(\":\");\n        const prefix = tagname.charAt(0) === \"/\" ? \"/\" : \"\";\n        if (tags[0] === \"xmlns\") {\n            return \"\";\n        }\n        if (tags.length === 2) {\n            tagname = prefix + tags[1];\n        }\n    }\n    return tagname;\n}\n\nfunction parseValue(val, shouldParse, parseTrueNumberOnly) {\n    if (shouldParse && typeof val === \"string\") {\n        let parsed;\n        if (val.trim() === \"\" || isNaN(val)) {\n            parsed = val === \"true\" ? true : val === \"false\" ? false : val;\n        } else {\n            if(val.indexOf(\"0x\") !== -1){//support hexa decimal\n                parsed = parseInt(val,16);\n            } else if (val.indexOf(\".\") !== -1) {\n                parsed = parseFloat(val);\n            } else {\n                parsed = parseInt(val, 10);\n            }\n            if(parseTrueNumberOnly){\n                parsed = String(parsed) === val ? parsed : val;\n                \n            }\n        }\n        return parsed;\n    } else {\n        if (util.isExist(val)) {\n            return val;\n        } else {\n            return \"\";\n        }\n    }\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp(\"([^\\\\s=]+)\\\\s*(=\\\\s*(['\\\"])(.*?)\\\\3)?\", \"g\");\n\nfunction buildAttributesMap(attrStr, options) {\n    if (!options.ignoreAttributes && typeof attrStr === \"string\") {\n        attrStr = attrStr.replace(/\\r?\\n/g, \" \");\n        //attrStr = attrStr || attrStr.trim();\n\n        const matches = util.getAllMatches(attrStr, attrsRegx);\n        const len = matches.length; //don't make it inline\n        const attrs = {};\n        for (let i = 0; i < len; i++) {\n            const attrName = resolveNameSpace(matches[i][1], options);\n            if (attrName.length) {\n                if (matches[i][4] !== undefined) {\n                    if (options.trimValues) {\n                        matches[i][4] = matches[i][4].trim();\n                    }\n                    matches[i][4] = options.attrValueProcessor(matches[i][4]);\n                    attrs[options.attributeNamePrefix + attrName] = parseValue(matches[i][4], options.parseAttributeValue, options.parseTrueNumberOnly);\n                } else if (options.allowBooleanAttributes) {\n                    attrs[options.attributeNamePrefix + attrName] = true;\n                }\n\n            }\n        }\n        if (!Object.keys(attrs).length) {\n            return;\n        }\n        if (options.attrNodeName) {\n            const attrCollection = {};\n            attrCollection[options.attrNodeName] = attrs;\n            return attrCollection;\n        }\n        return attrs;\n    }\n}\n\nexports.getTraversalObj = getTraversalObj;\n","\"use strict\";\n\nconst nodeToJson = require(\"./node2json\");\nconst xmlToNodeobj = require(\"./xmlstr2xmlnode\");\nconst x2xmlnode = require(\"./xmlstr2xmlnode\");\nconst buildOptions = require(\"./util\").buildOptions;\n\nexports.parse = function(xmlData, options) {\n    options = buildOptions(options, x2xmlnode.defaultOptions, x2xmlnode.props);\n    return nodeToJson.convertToJson(xmlToNodeobj.getTraversalObj(xmlData, options), options);\n};\nexports.convertTonimn = require(\"../src/nimndata\").convert2nimn;\nexports.getTraversalObj = xmlToNodeobj.getTraversalObj;\nexports.convertToJson = nodeToJson.convertToJson;\nexports.convertToJsonString = require(\"./node2json_str\").convertToJsonString;\nexports.validate = require(\"./validator\").validate;\nexports.j2xParser = require(\"./json2xml\");\nexports.parseToNimn = function (xmlData,schema,options){\n    return exports.convertTonimn(exports.getTraversalObj(xmlData,options), schema, options);\n};\n","\"use strict\";\n\nconst util = require(\"./util\");\n\nconst convertToJson =function(node, options) {\n    const jObj = {};\n\n    //when no child node or attr is present\n    if ((!node.child  ||  util.isEmptyObject(node.child)) && (!node.attrsMap || util.isEmptyObject(node.attrsMap))) {\n        return util.isExist(node.val) ? node.val : \"\";\n    } else { //otherwise create a textnode if node has some text\n        if (util.isExist(node.val)) {\n            if (!(typeof node.val === \"string\" && (node.val === \"\" || node.val === options.cdataPositionChar))) {\n                jObj[options.textNodeName] = node.val;\n            }\n        }\n    }\n\n    util.merge(jObj, node.attrsMap);\n\n    const keys = Object.keys(node.child);\n    for (let index = 0; index < keys.length; index++) {\n        var tagname = keys[index];\n        if (node.child[tagname] && node.child[tagname].length > 1) {\n            jObj[tagname] = [];\n            for (var tag in node.child[tagname]) {\n                jObj[tagname].push( convertToJson(node.child[tagname][tag], options) );\n            }\n        } else {\n            jObj[tagname] = convertToJson(node.child[tagname][0], options);\n        }\n    }\n    \n    //add value\n    return jObj;\n};\n\nexports.convertToJson = convertToJson;","\"use strict\";\n\nmodule.exports = function(tagname, parent, val) {\n    this.tagname = tagname;\n    this.parent = parent;\n    this.child = {};//child tags\n    this.attrsMap = {};//attributes map\n    this.val = val;//text only\n    this.addChild = function(child) {\n        if (this.child[child.tagname]) {//already presents\n            this.child[child.tagname].push(child);\n        } else {\n            this.child[child.tagname] = [child];\n        }\n    };\n};\n","\"use strict\";\nconst char = function(a) {\n    return String.fromCharCode(a);\n};\n\nconst chars = {\n    nilChar : char(176),\n    missingChar : char(201),\n    nilPremitive : char(175),\n    missingPremitive : char(200),\n\n    emptyChar : char(178),\n    emptyValue:  char(177),//empty Premitive\n    \n    boundryChar : char(179),\n    \n    objStart: char(198),\n    arrStart: char(204),\n    arrayEnd: char(185),\n};\n\nconst charsArr = [\n    chars.nilChar,\n    chars.nilPremitive,\n    chars.missingChar,\n    chars.missingPremitive,\n    chars.boundryChar,\n    chars.emptyChar,\n    chars.emptyValue,\n    chars.arrayEnd,\n    chars.objStart,\n    chars.arrStart\n];\n\nconst _e = function(node, e_schema, options) {\n    if (typeof e_schema === \"string\") {//premitive\n        if (node && node[0] && node[0].val !== undefined) {\n            return getValue(node[0].val, e_schema);\n        } else {\n            return getValue(node, e_schema);\n        }\n    } else {\n        const hasValidData = hasData(node);\n        if (hasValidData === true) {\n            let str = \"\";\n            if (Array.isArray(e_schema)) {\n                //attributes can't be repeated. hence check in children tags only\n                str += chars.arrStart;\n                const itemSchema = e_schema[0];\n                //var itemSchemaType = itemSchema;\n                const arr_len = node.length;\n\n                if (typeof itemSchema === \"string\") {\n                    for (let arr_i = 0; arr_i < arr_len; arr_i++) {\n                        const r = getValue(node[arr_i].val, itemSchema);\n                        str = processValue(str, r);\n                    }\n                } else {\n                    for (let arr_i = 0; arr_i < arr_len; arr_i++) {\n                        const r = _e(node[arr_i], itemSchema, options);\n                        str = processValue(str, r);\n                    }\n                }\n                str += chars.arrayEnd;//indicates that next item is not array item\n            } else {//object\n                str += chars.objStart;\n                const keys = Object.keys(e_schema);\n                if (Array.isArray(node)) {\n                    node = node[0];\n                }\n                for (let i in keys) {\n                    const key = keys[i];\n                    //a property defined in schema can be present either in attrsMap or children tags\n                    //options.textNodeName will not present in both maps, take it's value from val\n                    //options.attrNodeName will be present in attrsMap\n                    let r;\n                    if (!options.ignoreAttributes && node.attrsMap && node.attrsMap[key]) {\n                        r = _e(node.attrsMap[key], e_schema[key], options);\n                    } else if (key === options.textNodeName) {\n                        r = _e(node.val, e_schema[key], options);\n                    } else {\n                        r = _e(node.child[key], e_schema[key], options);\n                    }\n                    str = processValue(str, r);\n                }\n            }\n            return str;\n        } else {\n            return hasValidData;\n        }\n    }\n};\n\nconst getValue = function(a/*, type*/) {\n    switch (a) {\n        case undefined:\n            return chars.missingPremitive;\n        case null:\n            return chars.nilPremitive;\n        case \"\":\n            return chars.emptyValue;\n        default:\n            return a;\n    }\n};\n\nconst processValue = function(str, r) {\n    if (!isAppChar(r[0]) && !isAppChar(str[str.length - 1])) {\n        str += chars.boundryChar;\n    }\n    return str + r;\n};\n\nconst isAppChar = function(ch) {\n    return charsArr.indexOf(ch) !== -1;\n};\n\nfunction hasData(jObj) {\n    if (jObj === undefined) {\n        return chars.missingChar;\n    } else if (jObj === null) {\n        return chars.nilChar;\n    } else if (jObj.child && Object.keys(jObj.child).length === 0 && (!jObj.attrsMap || Object.keys(jObj.attrsMap).length === 0)) {\n        return chars.emptyChar;\n    } else {\n        return true;\n    }\n}\n\nconst x2j = require(\"./xmlstr2xmlnode\");\nconst buildOptions = require(\"./util\").buildOptions;\n\nconst convert2nimn = function(node, e_schema, options) {\n    options = buildOptions(options,x2j.defaultOptions,x2j.props);\n    return _e(node, e_schema, options);\n};\n\nexports.convert2nimn = convert2nimn;\n","\"use strict\";\n\nconst util = require(\"./util\");\nconst buildOptions = require(\"./util\").buildOptions;\nconst x2j = require(\"./xmlstr2xmlnode\");\n\n//TODO: do it later\nconst convertToJsonString = function(node, options) {\n    options = buildOptions(options,x2j.defaultOptions,x2j.props);\n\n    options.indentBy = options.indentBy || \"\";\n    return _cToJsonStr(node, options,0);\n}\n\nconst _cToJsonStr = function(node, options,level) {\n    let jObj = \"{\";\n\n    //traver through all the children\n    const keys = Object.keys(node.child);\n    \n    for (let index = 0; index < keys.length; index++) {\n        var tagname = keys[index];\n        if (node.child[tagname] && node.child[tagname].length > 1) {\n            jObj  += \"\\\"\" + tagname + \"\\\" : [ \";\n            for (var tag in node.child[tagname]) {\n                jObj += _cToJsonStr(node.child[tagname][tag], options) + \" , \";\n            }\n            jObj = jObj.substr(0,jObj.length-1) + \" ] \"; //remove extra comma in last\n        } else {\n            jObj += \"\\\"\" +tagname + \"\\\" : \" + _cToJsonStr(node.child[tagname][0], options) + \" ,\";\n        }\n    }\n    util.merge(jObj, node.attrsMap);\n    //add attrsMap as new children\n    if (util.isEmptyObject(jObj)) {\n        return util.isExist(node.val) ? node.val : \"\";\n    } else {\n        if (util.isExist(node.val)) {\n            if (!(typeof node.val === \"string\" && (node.val === \"\" || node.val === options.cdataPositionChar))) {\n                jObj += \"\\\"\" + options.textNodeName +\"\\\" : \" + stringval(node.val);\n            }\n        }\n    }\n    //add value\n    if(jObj[jObj.length-1] === \",\"){\n        jObj = jObj.substr(0,jObj.length-2);\n    }\n    return jObj + \"}\";\n};\n\nfunction stringval(v){\n    if(v === true || v === false || !isNaN(v)){\n        return v;\n    }else{\n        return \"\\\"\" + v + \"\\\"\";\n    }\n}\n\nfunction indentate(options, level) {\n    return options.indentBy.repeat(level);\n}\n\nexports.convertToJsonString = convertToJsonString;","\"use strict\";\n\nconst util = require(\"./util\");\n\nconst defaultOptions = {\n    allowBooleanAttributes: false,         //A tag can have attributes without any value\n    localeRange:  \"a-zA-Z\"\n};\n\nconst props = [\"allowBooleanAttributes\", \"localeRange\"];\n\n//const tagsPattern = new RegExp(\"<\\\\/?([\\\\w:\\\\-_\\.]+)\\\\s*\\/?>\",\"g\");\nexports.validate = function(xmlData, options) {\n    options = util.buildOptions(options,defaultOptions,props);\n\n    //xmlData = xmlData.replace(/(\\r\\n|\\n|\\r)/gm,\"\");//make it single line\n    //xmlData = xmlData.replace(/(^\\s*<\\?xml.*?\\?>)/g,\"\");//Remove XML starting tag\n    //xmlData = xmlData.replace(/(<!DOCTYPE[\\s\\w\\\"\\.\\/\\-\\:]+(\\[.*\\])*\\s*>)/g,\"\");//Remove DOCTYPE\n\n    const tags = [];\n    let tagFound = false;\n    if (xmlData[0] === \"\\ufeff\") {  // check for byte order mark (BOM)\n      xmlData = xmlData.substr(1);\n    }\n    const regxAttrName = new RegExp(\"^[_w][\\\\w\\\\-.:]*$\".replace(\"_w\", \"_\" + options.localeRange));\n    const regxTagName = new RegExp(\"^([w]|_)[\\\\w.\\\\-_:]*\".replace(\"([w\", \"([\" + options.localeRange));\n    for (let i = 0; i < xmlData.length; i++) {\n\n        if (xmlData[i] === \"<\") { //starting of tag\n            //read until you reach to '>' avoiding any '>' in attribute value\n\n            i++;\n            if (xmlData[i] === \"?\") {\n                i = readPI(xmlData, ++i);\n                if (i.err) {\n                    return i;\n                }\n            } else if (xmlData[i] === \"!\") {\n                i = readCommentAndCDATA(xmlData, i);\n                continue;\n            } else {\n                let closingTag = false;\n                if (xmlData[i] === \"/\") {//closing tag\n                    closingTag = true;\n                    i++;\n                }\n                //read tagname\n                let tagName = \"\";\n                for (; i < xmlData.length &&\n                       xmlData[i] !== \">\" &&\n                       xmlData[i] !== \" \" &&\n                       xmlData[i] !== \"\\t\"; i++) {\n\n                    tagName += xmlData[i];\n                }\n                tagName = tagName.trim();\n                //console.log(tagName);\n\n                if (tagName[tagName.length - 1] === \"/\") {//self closing tag without attributes\n                    tagName = tagName.substring(0, tagName.length - 1);\n                    continue;\n                }\n                if (!validateTagName(tagName, regxTagName)) {\n                    return {err: {code: \"InvalidTag\", msg: \"Tag \" + tagName + \" is an invalid name.\"}};\n                }\n\n                const result = readAttributeStr(xmlData, i);\n                if (result === false) {\n                    return {err: {code: \"InvalidAttr\", msg: \"Attributes for \" + tagName + \" have open quote\"}};\n                }\n                let attrStr = result.value;\n                i = result.index;\n\n                if (attrStr[attrStr.length - 1] === \"/\") {//self closing tag\n                    attrStr = attrStr.substring(0, attrStr.length - 1);\n                    const isValid = validateAttributeString(attrStr, options, regxAttrName);\n                    if (isValid === true) {\n                        tagFound = true;\n                        //continue; //text may presents after self closing tag\n                    } else {\n                        return isValid;\n                    }\n                } else if (closingTag) {\n                    if (attrStr.trim().length > 0) {\n                        return {err: {code: \"InvalidTag\", msg: \"closing tag \" + tagName + \" can't have attributes or invalid starting.\"}};\n                    } else {\n                        const otg = tags.pop();\n                        if (tagName !== otg) {\n                            return {err: {code: \"InvalidTag\", msg: \"closing tag \" + otg + \" is expected inplace of \" + tagName + \".\"}};\n                        }\n                    }\n                } else {\n                    const isValid = validateAttributeString(attrStr, options, regxAttrName);\n                    if (isValid !== true) {\n                        return isValid;\n                    }\n                    tags.push(tagName);\n                    tagFound = true;\n                }\n\n                //skip tag text value\n                //It may include comments and CDATA value\n                for (i++; i < xmlData.length; i++) {\n                    if (xmlData[i] === \"<\") {\n                        if (xmlData[i + 1] === \"!\") {//comment or CADATA\n                            i++;\n                            i = readCommentAndCDATA(xmlData, i);\n                            continue;\n                        } else {\n                            break;\n                        }\n                    }\n                }//end of reading tag text value\n                if (xmlData[i] === \"<\") {\n                    i--;\n                }\n            }\n        } else {\n            if (xmlData[i] === \" \" || xmlData[i] === \"\\t\" || xmlData[i] === \"\\n\" || xmlData[i] === \"\\r\") {\n                continue;\n            }\n            return {err: {code: \"InvalidChar\", msg: \"char \" + xmlData[i] + \" is not expected .\"}};\n        }\n    }\n\n    if (!tagFound) {\n        return {err: {code: \"InvalidXml\", msg: \"Start tag expected.\"}};\n    } else if (tags.length > 0) {\n        return {err: {code: \"InvalidXml\", msg: \"Invalid \" + JSON.stringify(tags, null, 4).replace(/\\r?\\n/g, \"\") + \" found.\"}};\n    }\n\n    return true;\n};\n\n/**\n * Read Processing insstructions and skip\n * @param {*} xmlData\n * @param {*} i\n */\nfunction readPI(xmlData, i) {\n    var start = i;\n    for (; i < xmlData.length; i++) {\n        if (xmlData[i] == \"?\" || xmlData[i] == \" \") {//tagname\n            var tagname = xmlData.substr(start, i - start);\n            if (i > 5 && tagname === \"xml\") {\n                return {err: {code: \"InvalidXml\", msg: \"XML declaration allowed only at the start of the document.\"}};\n            } else if (xmlData[i] == \"?\" && xmlData[i + 1] == \">\") {\n                //check if valid attribut string\n                i++;\n                break;\n            } else {\n                continue;\n            }\n        }\n    }\n    return i;\n}\n\nfunction readCommentAndCDATA(xmlData, i) {\n    if (xmlData.length > i + 5 && xmlData[i + 1] === \"-\" && xmlData[i + 2] === \"-\") {//comment\n        for (i += 3; i < xmlData.length; i++) {\n            if (xmlData[i] === \"-\" && xmlData[i + 1] === \"-\" && xmlData[i + 2] === \">\") {\n                i += 2;\n                break;\n            }\n        }\n    } else if (xmlData.length > i + 8 &&\n               xmlData[i + 1] === \"D\" &&\n               xmlData[i + 2] === \"O\" &&\n               xmlData[i + 3] === \"C\" &&\n               xmlData[i + 4] === \"T\" &&\n               xmlData[i + 5] === \"Y\" &&\n               xmlData[i + 6] === \"P\" &&\n               xmlData[i + 7] === \"E\") {\n        let angleBracketsCount = 1;\n        for (i += 8; i < xmlData.length; i++) {\n            if (xmlData[i] === \"<\") {angleBracketsCount++;}\n            else if (xmlData[i] === \">\") {\n                angleBracketsCount--;\n                if (angleBracketsCount === 0) {\n                    break;\n                }\n            }\n        }\n    } else if (xmlData.length > i + 9 &&\n               xmlData[i + 1] === \"[\" &&\n               xmlData[i + 2] === \"C\" &&\n               xmlData[i + 3] === \"D\" &&\n               xmlData[i + 4] === \"A\" &&\n               xmlData[i + 5] === \"T\" &&\n               xmlData[i + 6] === \"A\" &&\n               xmlData[i + 7] === \"[\") {\n\n        for (i += 8; i < xmlData.length; i++) {\n            if (xmlData[i] === \"]\" && xmlData[i + 1] === \"]\" && xmlData[i + 2] === \">\") {\n                i += 2;\n                break;\n            }\n        }\n    }\n\n    return i;\n}\n\nvar doubleQuote = \"\\\"\";\nvar singleQuote = \"'\";\n\n/**\n * Keep reading xmlData until '<' is found outside the attribute value.\n * @param {string} xmlData\n * @param {number} i\n */\nfunction readAttributeStr(xmlData, i) {\n    let attrStr = \"\";\n    let startChar = \"\";\n    for (; i < xmlData.length; i++) {\n        if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\n            if (startChar === \"\") {\n                startChar = xmlData[i];\n            } else if (startChar !== xmlData[i]) {\n                //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa\n                continue;\n            } else {\n                startChar = \"\";\n            }\n        } else if (xmlData[i] === \">\") {\n            if (startChar === \"\") {\n                break;\n            }\n        }\n        attrStr += xmlData[i];\n    }\n    if (startChar !== \"\") {\n        return false;\n    }\n\n    return {value: attrStr, index: i};\n}\n\n/**\n * Select all the attributes whether valid or invalid.\n */\nconst validAttrStrRegxp = new RegExp(\"(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*(['\\\"])(([\\\\s\\\\S])*?)\\\\5)?\", \"g\");\n\n//attr, =\"sd\", a=\"amit's\", a=\"sd\"b=\"saf\", ab  cd=\"\"\n\nfunction validateAttributeString(attrStr, options, regxAttrName) {\n    //console.log(\"start:\"+attrStr+\":end\");\n\n    //if(attrStr.trim().length === 0) return true; //empty string\n\n    const matches = util.getAllMatches(attrStr, validAttrStrRegxp);\n    const attrNames = [];\n\n    for (let i = 0; i < matches.length; i++) {\n        //console.log(matches[i]);\n\n        if (matches[i][1].length === 0) {//nospace before attribute name: a=\"sd\"b=\"saf\"\n            return {err: {code: \"InvalidAttr\", msg: \"attribute \" + matches[i][2] + \" has no space in starting.\"}};\n        } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {//independent attribute: ab\n            return {err: {code: \"InvalidAttr\", msg: \"boolean attribute \" + matches[i][2] + \" is not allowed.\"}};\n        }\n        /* else if(matches[i][6] === undefined){//attribute without value: ab=\n                    return { err: { code:\"InvalidAttr\",msg:\"attribute \" + matches[i][2] + \" has no value assigned.\"}};\n                } */\n        const attrName = matches[i][2];\n        if (!validateAttrName(attrName, regxAttrName)) {\n            return {err: {code: \"InvalidAttr\", msg: \"attribute \" + attrName + \" is an invalid name.\"}};\n        }\n        if (!attrNames.hasOwnProperty(attrName)) {//check for duplicate attribute.\n            attrNames[attrName] = 1;\n        } else {\n            return {err: {code: \"InvalidAttr\", msg: \"attribute \" + attrName + \" is repeated.\"}};\n        }\n    }\n\n    return true;\n\n}\n\n// const validAttrRegxp = /^[_a-zA-Z][\\w\\-.:]*$/;\n\nfunction validateAttrName(attrName, regxAttrName) {\n    // const validAttrRegxp = new RegExp(regxAttrName);\n    return util.doesMatch(attrName, regxAttrName);\n}\n\n//const startsWithXML = new RegExp(\"^[Xx][Mm][Ll]\");\n//  startsWith = /^([a-zA-Z]|_)[\\w.\\-_:]*/;\n\nfunction validateTagName(tagname, regxTagName) {\n    /*if(util.doesMatch(tagname,startsWithXML)) return false;\n    else*/\n    return !util.doesNotMatch(tagname, regxTagName);\n}\n","\"use strict\";\n//parse Empty Node as self closing node\nconst buildOptions = require(\"./util\").buildOptions;\n\nconst defaultOptions = {\n    attributeNamePrefix: \"@_\",\n    attrNodeName: false,\n    textNodeName: \"#text\",\n    ignoreAttributes: true,\n    cdataTagName: false,\n    cdataPositionChar: \"\\\\c\",\n    format: false,\n    indentBy: \"  \",\n    supressEmptyNode: false,\n    inlineEmptyNode: false,\n    tagValueProcessor: function(a) {return a},\n    attrValueProcessor: function(a) {return a}\n};\n\nconst props = [\n    \"attributeNamePrefix\",\n    \"attrNodeName\",\n    \"textNodeName\",\n    \"ignoreAttributes\",\n    \"cdataTagName\",\n    \"cdataPositionChar\",\n    \"format\",\n    \"indentBy\",\n    \"supressEmptyNode\",\n    \"inlineEmptyNode\",\n    \"tagValueProcessor\",\n    \"attrValueProcessor\"\n]\n\nfunction Parser(options) {\n    this.options = buildOptions(options,defaultOptions,props);\n    if (this.options.ignoreAttributes || this.options.attrNodeName) {\n        this.isAttribute = function(/*a*/) { return false;};\n    } else {\n        this.attrPrefixLen = this.options.attributeNamePrefix.length;\n        this.isAttribute = isAttribute;\n    }\n    if (this.options.cdataTagName) {\n        this.isCDATA = isCDATA;\n    } else {\n        this.isCDATA = function(/*a*/) { return false;};\n    }\n    this.replaceCDATAstr = replaceCDATAstr;\n    this.replaceCDATAarr = replaceCDATAarr;\n    this.inlineEmptyNode = !!this.options.inlineEmptyNode;\n\n    if (this.options.format) {\n        this.indentate = indentate;\n        this.tagEndChar = \">\\n\";\n        this.newLine = \"\\n\";\n    } else {\n        this.indentate = function() { return \"\";};\n        this.tagEndChar = \">\";\n        this.newLine = \"\";\n    }\n\n    if (this.options.supressEmptyNode) {\n        this.buildTextNode = buildEmptyTextNode;\n        this.buildObjNode = buildEmptyObjNode;\n    } else {\n        this.buildTextNode = buildTextValNode;\n        this.buildObjNode = buildObjectNode;\n    }\n\n    this.buildTextValNode = buildTextValNode;\n    this.buildObjectNode = buildObjectNode;\n\n}\n\nParser.prototype.parse = function(jObj) {\n    return this.j2x(jObj, 0).val;\n};\n\nParser.prototype.j2x = function(jObj, level) {\n    let attrStr = \"\";\n    let val = \"\";\n    const keys = Object.keys(jObj);\n    const len = keys.length;\n    for (let i = 0; i < len; i++) {\n        const key = keys[i];\n        if (typeof jObj[key] === \"undefined\") {\n            // supress undefined node\n        }else if (jObj[key] === null) {\n            val += this.indentate(level) + \"<\" + key + \"/\" + this.tagEndChar;\n        }else if (typeof jObj[key] !== \"object\") {//premitive type\n            const attr = this.isAttribute(key);\n            if (attr) {\n                attrStr += \" \" + attr + \"=\\\"\" +  this.options.attrValueProcessor(\"\" + jObj[key]) + \"\\\"\";\n            } else if (this.isCDATA(key)) {\n                if (jObj[this.options.textNodeName]) {\n                    val += this.replaceCDATAstr(jObj[this.options.textNodeName], jObj[key]);\n                } else {\n                    val += this.replaceCDATAstr(\"\", jObj[key]);\n                }\n            } else {//tag value\n                if (key === this.options.textNodeName) {\n                    if (jObj[this.options.cdataTagName]) {\n                        //value will added while processing cdata\n                    } else {\n                        val +=  this.options.tagValueProcessor(\"\" + jObj[key]);\n                    }\n                } else {\n                    val += this.buildTextNode(jObj[key], key, \"\", level);\n                }\n            }\n        } else if (Array.isArray(jObj[key])) {//repeated nodes\n            if (this.isCDATA(key)) {\n              val += this.indentate(level)\n                if (jObj[this.options.textNodeName]) {\n                  val += this.replaceCDATAarr(jObj[this.options.textNodeName], jObj[key]);\n                } else {\n                  val += this.replaceCDATAarr(\"\", jObj[key]);\n                }\n            } else {//nested nodes\n                const arrLen = jObj[key].length;\n                for (let j = 0; j < arrLen; j++) {\n                    const item = jObj[key][j];\n                    if (typeof item === \"undefined\") {\n                        // supress undefined node\n                    }else if(item === null){\n                        val += this.indentate(level) + \"<\" + key + \"/\" + this.tagEndChar;\n                    }else if (typeof item === \"object\") {\n                        const result = this.j2x(item, level + 1);\n                        val += this.buildObjNode(result.val, key, result.attrStr, level);\n                    } else {\n                        val += this.buildTextNode(item, key, \"\", level);\n                    }\n                }\n            }\n        } else {//nested node\n            if (this.options.attrNodeName && key === this.options.attrNodeName) {\n                const Ks = Object.keys(jObj[key]);\n                const L = Ks.length;\n                for (let j = 0; j < L; j++) {\n                    attrStr += \" \" + Ks[j] + \"=\\\"\" + this.options.tagValueProcessor(\"\" + jObj[key][Ks[j]]) + \"\\\"\";\n                }\n            } else {\n                const result = this.j2x(jObj[key], level + 1);\n                val += this.buildObjNode(result.val, key, result.attrStr, level);\n            }\n        }\n    }\n    return {attrStr: attrStr, val: val};\n};\n\nfunction replaceCDATAstr(str, cdata) {\n    str = this.options.tagValueProcessor(\"\" + str);\n    if (this.options.cdataPositionChar === \"\" || str === \"\") {\n        return str + \"<![CDATA[\" + cdata + \"]]\" + this.tagEndChar;\n    } else {\n        return str.replace(this.options.cdataPositionChar, \"<![CDATA[\" + cdata + \"]]\" + this.tagEndChar);\n    }\n}\n\nfunction replaceCDATAarr(str, cdata) {\n    str = this.options.tagValueProcessor(\"\" + str);\n    if (this.options.cdataPositionChar === \"\" || str === \"\") {\n        return str + \"<![CDATA[\" + cdata.join(\"]]><![CDATA[\") + \"]]\" + this.tagEndChar;\n    } else {\n        for (let v in cdata) {\n            str = str.replace(this.options.cdataPositionChar, \"<![CDATA[\" + cdata[v] + \"]]>\");\n        }\n        return str + this.newLine;\n    }\n}\n\nfunction buildObjectNode(val, key, attrStr, level) {\n  if (attrStr && !val.includes('<')) {\n    return this.indentate(level)\n          + \"<\" + key + attrStr\n          + \">\"\n          + val\n          //+ this.newLine\n          // + this.indentate(level)\n          + \"</\" + key + this.tagEndChar;\n  } else {\n    if(val.length === 0 && this.inlineEmptyNode) {\n        return `${this.indentate(level)}<${key + attrStr}></${key}${this.tagEndChar}`;\n    } else {\n        return this.indentate(level)\n            + \"<\" + key + attrStr\n            + this.tagEndChar\n            + val\n            //+ this.newLine\n            + this.indentate(level)\n            + \"</\" + key + this.tagEndChar;\n    }\n  }\n}\n\nfunction buildEmptyObjNode(val, key, attrStr, level) {\n    if (val !== \"\") {\n        return this.buildObjectNode(val, key, attrStr, level);\n    } else {\n        return this.indentate(level)\n               + \"<\" + key + attrStr\n               + \"/\"\n               + this.tagEndChar;\n        //+ this.newLine\n    }\n}\n\nfunction buildTextValNode(val, key, attrStr, level) {\n    const tagValue = this.options.tagValueProcessor(\"\" + val);\n    if(tagValue.length === 0 && this.inlineEmptyNode) {\n        return `${this.indentate(level)}<${key + attrStr}></${key}${this.tagEndChar}`;\n    } else {\n        return this.indentate(level) + \"<\" + key + attrStr + \">\" + tagValue + \"</\" + key + this.tagEndChar;\n    }\n}\n\nfunction buildEmptyTextNode(val, key, attrStr, level) {\n    if (val !== \"\") {\n        return this.buildTextValNode(val, key, attrStr, level);\n    } else {\n        return this.indentate(level) + \"<\" + key + attrStr + \"/\" + this.tagEndChar;\n    }\n}\n\nfunction indentate(level) {\n    return this.options.indentBy.repeat(level);\n}\n\nfunction isAttribute(name/*, options*/) {\n    if (name.startsWith(this.options.attributeNamePrefix)) {\n        return name.substr(this.attrPrefixLen);\n    } else {\n        return false;\n    }\n}\n\nfunction isCDATA(name) {\n    return name === this.options.cdataTagName;\n}\n\n//formatting\n//indentation\n//\\n after each closing or self closing tag\n\nmodule.exports = Parser;\n"],"sourceRoot":""}