{"version":3,"sources":["webpack://parser/webpack/bootstrap","webpack://parser/./src/util.js","webpack://parser/./src/xmlstr2xmlnode.js","webpack://parser/./src/parser.js","webpack://parser/./src/node2json.js","webpack://parser/./src/xmlNode.js","webpack://parser/./src/nimndata.js","webpack://parser/./src/node2json_str.js","webpack://parser/./src/validator.js","webpack://parser/./src/json2xml.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","doesMatch","string","regex","match","exec","isExist","v","isEmptyObject","obj","keys","length","merge","target","a","len","getValue","buildOptions","options","defaultOptions","props","newOptions","undefined","doesNotMatch","getAllMatches","matches","allmatches","index","push","util","xmlNode","TagType","OPENING","CLOSING","SELF","CDATA","regx","attributeNamePrefix","attrNodeName","textNodeName","ignoreAttributes","ignoreNameSpace","allowBooleanAttributes","parseNodeValue","parseAttributeValue","arrayMode","trimValues","cdataTagName","cdataPositionChar","localeRange","tagValueProcessor","attrValueProcessor","processTagValue","val","trim","parseValue","parseTrueNumberOnly","checkForTagType","substr","resolveNameSpace","tagname","tags","split","prefix","charAt","shouldParse","parsed","isNaN","indexOf","Number","parseInt","parseFloat","String","attrsRegx","RegExp","buildAttributesMap","attrStr","replace","attrs","attrName","attrCollection","getTraversalObj","xmlData","xmlObj","currentNode","tagsRegx","tag","nextTag","tagType","parent","childNode","attrsMap","addChild","nodeToJson","xmlToNodeobj","x2xmlnode","parse","convertToJson","convertTonimn","convert2nimn","convertToJsonString","validate","j2xParser","parseToNimn","schema","node","jObj","child","this","char","fromCharCode","chars","nilChar","missingChar","nilPremitive","missingPremitive","emptyChar","emptyValue","boundryChar","objStart","arrStart","arrayEnd","charsArr","_e","e_schema","hasValidData","hasData","str","Array","isArray","itemSchema","arr_len","arr_i","processValue","isAppChar","ch","x2j","_cToJsonStr","level","stringval","indentBy","readPI","start","err","code","msg","readCommentAndCDATA","angleBracketsCount","tagFound","regxAttrName","regxTagName","closingTag","tagName","substring","validateTagName","result","readAttributeStr","isValid","validateAttributeString","otg","pop","JSON","stringify","doubleQuote","singleQuote","startChar","validAttrStrRegxp","attrNames","validateAttrName","format","supressEmptyNode","Parser","isAttribute","attrPrefixLen","isCDATA","replaceCDATAstr","replaceCDATAarr","indentate","tagEndChar","newLine","buildTextNode","buildEmptyTextNode","buildObjNode","buildEmptyObjNode","buildTextValNode","buildObjectNode","cdata","join","includes","repeat","startsWith","j2x","attr","arrLen","j","item","Ks","L"],"mappings":"uBACA,IAAAA,KAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAC,QAGA,IAAAC,EAAAJ,EAAAE,IACAG,EAAAH,EACAI,GAAA,EACAH,YAUA,OANAI,EAAAL,GAAAM,KAAAJ,EAAAD,QAAAC,IAAAD,QAAAF,GAGAG,EAAAE,GAAA,EAGAF,EAAAD,QA0DA,OArDAF,EAAAQ,EAAAF,EAGAN,EAAAS,EAAAV,EAGAC,EAAAU,EAAA,SAAAR,EAAAS,EAAAC,GACAZ,EAAAa,EAAAX,EAAAS,IACAG,OAAAC,eAAAb,EAAAS,GAA0CK,YAAA,EAAAC,IAAAL,KAK1CZ,EAAAkB,EAAA,SAAAhB,GACA,oBAAAiB,eAAAC,aACAN,OAAAC,eAAAb,EAAAiB,OAAAC,aAAwDC,MAAA,WAExDP,OAAAC,eAAAb,EAAA,cAAiDmB,OAAA,KAQjDrB,EAAAsB,EAAA,SAAAD,EAAAE,GAEA,GADA,EAAAA,IAAAF,EAAArB,EAAAqB,IACA,EAAAE,EAAA,OAAAF,EACA,KAAAE,GAAA,iBAAAF,QAAAG,WAAA,OAAAH,EACA,IAAAI,EAAAX,OAAAY,OAAA,MAGA,GAFA1B,EAAAkB,EAAAO,GACAX,OAAAC,eAAAU,EAAA,WAAyCT,YAAA,EAAAK,UACzC,EAAAE,GAAA,iBAAAF,EAAA,QAAAM,KAAAN,EAAArB,EAAAU,EAAAe,EAAAE,EAAA,SAAAA,GAAgH,OAAAN,EAAAM,IAAqBC,KAAA,KAAAD,IACrI,OAAAF,GAIAzB,EAAA6B,EAAA,SAAA1B,GACA,IAAAS,EAAAT,KAAAqB,WACA,WAA2B,OAAArB,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAH,EAAAU,EAAAE,EAAA,IAAAA,GACAA,GAIAZ,EAAAa,EAAA,SAAAiB,EAAAC,GAAsD,OAAAjB,OAAAkB,UAAAC,eAAA1B,KAAAuB,EAAAC,IAGtD/B,EAAAkC,EAAA,GAIAlC,IAAAmC,EAAA,kCChFA,IAeMC,EAAY,SAASC,EAAQC,GAC/B,IAAMC,EAAQD,EAAME,KAAKH,GACzB,QAAmB,OAAVE,QAAmC,IAAVA,IAOtCrC,EAAQuC,QAAU,SAASC,GACvB,YAAoB,IAANA,GAGlBxC,EAAQyC,cAAgB,SAASC,GAC7B,OAAmC,IAA5B9B,OAAO+B,KAAKD,GAAKE,QAQ5B5C,EAAQ6C,MAAQ,SAASC,EAAQC,GAC7B,GAAIA,EAGA,IAFA,IAAMJ,EAAO/B,OAAO+B,KAAKI,GACnBC,EAAML,EAAKC,OACR1C,EAAI,EAAGA,EAAI8C,EAAK9C,IACrB4C,EAAOH,EAAKzC,IAAM6C,EAAEJ,EAAKzC,KAQrCF,EAAQiD,SAAW,SAAST,GACxB,OAAIxC,EAAQuC,QAAQC,GACTA,EAEA,IAOfxC,EAAQkD,aAAe,SAASC,EAAQC,EAAeC,GACnD,IAAIC,KACJ,IAAKH,EACD,OAAOC,EAGX,IAAK,IAAIlD,EAAI,EAAGA,EAAImD,EAAMT,OAAQ1C,SACHqD,IAAtBJ,EAAQE,EAAMnD,IACfoD,EAAWD,EAAMnD,IAAMiD,EAAQE,EAAMnD,IAErCoD,EAAWD,EAAMnD,IAAMkD,EAAeC,EAAMnD,IAGpD,OAAOoD,GAGXtD,EAAQkC,UAAYA,EACpBlC,EAAQwD,aA1Da,SAASrB,EAAQC,GAClC,OAAQF,EAAUC,EAAQC,IA0D9BpC,EAAQyD,cA/Ec,SAAStB,EAAQC,GAGnC,IAFA,IAAMsB,KACFrB,EAAQD,EAAME,KAAKH,GAChBE,GAAO,CAGV,IAFA,IAAMsB,KACAX,EAAMX,EAAMO,OACTgB,EAAQ,EAAGA,EAAQZ,EAAKY,IAC7BD,EAAWE,KAAKxB,EAAMuB,IAE1BF,EAAQG,KAAKF,GACbtB,EAAQD,EAAME,KAAKH,GAEvB,OAAOuB,iCCZX,IAAMI,EAAOhE,EAAQ,GACfoD,EAAepD,EAAQ,GAAUoD,aACjCa,EAAUjE,EAAQ,GAClBkE,GAAWC,QAAW,EAAGC,QAAW,EAAGC,KAAQ,EAAGC,MAAS,GAC7DC,EAAO,kIAOLjB,GACFkB,oBAAwB,KACxBC,cAAwB,EACxBC,aAAwB,QACxBC,kBAAwB,EACxBC,iBAAwB,EACxBC,wBAAwB,EAExBC,gBAAwB,EACxBC,qBAAwB,EACxBC,WAAwB,EACxBC,YAAwB,EACxBC,cAAwB,EACxBC,kBAAwB,MACxBC,YAAwB,GACxBC,kBAAmB,SAASpC,GAAI,OAAOA,GACvCqC,mBAAoB,SAASrC,GAAI,OAAOA,IAI5C/C,EAAQoD,eAAiBA,EAEzB,IAAMC,GAAS,sBAAuB,eAAgB,eAAgB,mBAAoB,kBAAmB,yBAA0B,iBAAkB,sBAAuB,YAAa,aAAc,eAAgB,oBAAqB,cAAe,oBAAqB,qBAAsB,uBAC1SrD,EAAQqD,MAAQA,EAgEhB,SAASgC,EAAgBC,EAAKnC,GAS1B,OARImC,IACInC,EAAQ4B,aACRO,EAAMA,EAAIC,QAGdD,EAAME,EADNF,EAAMnC,EAAQgC,kBAAkBG,GACVnC,EAAQyB,eAAgBzB,EAAQsC,sBAGnDH,EAGX,SAASI,EAAgBrD,GACrB,MAAiB,QAAbA,EAAM,GACC2B,EAAQI,MACM,MAAd/B,EAAM,IACN2B,EAAQE,aACY,IAAb7B,EAAM,IAA+D,MAAzCA,EAAM,GAAGsD,OAAOtD,EAAM,GAAGO,OAAS,GACrEoB,EAAQG,KAERH,EAAQC,QAIvB,SAAS2B,EAAiBC,EAAS1C,GAC/B,GAAIA,EAAQuB,gBAAiB,CACzB,IAAMoB,EAAOD,EAAQE,MAAM,KACrBC,EAA+B,MAAtBH,EAAQI,OAAO,GAAa,IAAM,GACjD,GAAgB,UAAZH,EAAK,GACL,MAAO,GAES,IAAhBA,EAAKlD,SACLiD,EAAUG,EAASF,EAAK,IAGhC,OAAOD,EAGX,SAASL,EAAWF,EAAKY,EAAaT,GAE9B,IAAIU,EADR,OAAID,GAA8B,iBAARZ,GAEH,KAAfA,EAAIC,QAAiBa,MAAMd,GAC3Ba,EAAiB,SAARb,GAAgC,UAARA,GAA0BA,GAGvDa,GADsB,IAAvBb,EAAIe,QAAQ,MACFC,OAAOC,SAASjB,EAAI,KACA,IAAtBA,EAAIe,QAAQ,KACVC,OAAOE,WAAWlB,GAElBgB,OAAOC,SAASjB,EAAK,IAE/BG,IACCU,EAASM,OAAON,KAAYb,EAAMa,EAASb,IAI5Ca,GAEHrC,EAAKvB,QAAQ+C,GACNA,EAEA,GAOnB,IAAMoB,EAAY,IAAIC,OAAO,wCAAyC,KAEtE,SAASC,EAAmBC,EAAS1D,GACjC,IAAKA,EAAQsB,kBAAuC,iBAAZoC,EAAsB,CAC1DA,EAAUA,EAAQC,QAAQ,SAAU,KAMpC,IAHA,IAAMpD,EAAUI,EAAKL,cAAcoD,EAASH,GACtC1D,EAAMU,EAAQd,OACdmE,KACG7G,EAAI,EAAGA,EAAI8C,EAAK9C,IAAK,CAC1B,IAAM8G,EAAWpB,EAAiBlC,EAAQxD,GAAG,GAAIiD,GAC7C6D,EAASpE,cACaW,IAAlBG,EAAQxD,GAAG,IACPiD,EAAQ4B,aACRrB,EAAQxD,GAAG,GAAKwD,EAAQxD,GAAG,GAAGqF,QAElC7B,EAAQxD,GAAG,GAAKiD,EAAQiC,mBAAmB1B,EAAQxD,GAAG,IACtD6G,EAAM5D,EAAQmB,oBAAsB0C,GAAYxB,EAAW9B,EAAQxD,GAAG,GAAIiD,EAAQ0B,oBAAqB1B,EAAQsC,sBACxGtC,EAAQwB,yBACfoC,EAAM5D,EAAQmB,oBAAsB0C,IAAY,IAK5D,IAAKpG,OAAO+B,KAAKoE,GAAOnE,OACpB,OAEJ,GAAIO,EAAQoB,aAAc,CACtB,IAAM0C,KAEN,OADAA,EAAe9D,EAAQoB,cAAgBwC,EAChCE,EAEX,OAAOF,GAIf/G,EAAQkH,gBAvKgB,SAASC,EAAShE,GACtCA,EAAUD,EAAaC,EAAQC,EAAeC,GAE9C8D,EAAUA,EAAQL,QAAQ,mBAAoB,IAE9C,IAAMM,EAAS,IAAIrD,EAAQ,QACvBsD,EAAcD,EAElB/C,EAAOA,EAAKyC,QAAQ,SAAU,IAAM3D,EAAQ+B,YAAc,OAI1D,IAHA,IAAMoC,EAAW,IAAIX,OAAOtC,EAAM,KAC9BkD,EAAMD,EAAShF,KAAK6E,GACpBK,EAAUF,EAAShF,KAAK6E,GACrBI,GAAK,CACR,IAAME,EAAU/B,EAAgB6B,GAEhC,GAAIE,IAAYzD,EAAQE,QAEhBmD,EAAYK,QAAUH,EAAI,MAC1BF,EAAYK,OAAOpC,IAAMxB,EAAKb,SAASoE,EAAYK,OAAOpC,KAAO,GAAKD,EAAgBkC,EAAI,IAAKpE,IAGnGkE,EAAcA,EAAYK,YACvB,GAAID,IAAYzD,EAAQI,MAC3B,GAAIjB,EAAQ6B,aAAc,CAEtB,IAAM2C,EAAY,IAAI5D,EAAQZ,EAAQ6B,aAAcqC,EAAaE,EAAI,IACrEI,EAAUC,SAAWhB,EAAmBW,EAAI,GAAIpE,GAChDkE,EAAYQ,SAASF,GAErBN,EAAY/B,IAAMxB,EAAKb,SAASoE,EAAY/B,KAAOnC,EAAQ8B,kBAEvDsC,EAAI,MACJF,EAAY/B,KAAOD,EAAgBkC,EAAI,IAAKpE,SAGhDkE,EAAY/B,KAAO+B,EAAY/B,KAAO,KAAOiC,EAAI,IAAM,IAAMlC,EAAgBkC,EAAI,IAAKpE,QAEvF,GAAIsE,IAAYzD,EAAQG,KAAM,CAC7BkD,GAAeE,EAAI,MACnBF,EAAY/B,IAAMxB,EAAKb,SAASoE,EAAY/B,KAAO,GAAKD,EAAgBkC,EAAI,IAAKpE,IAGrF,IAAMwE,EAAY,IAAI5D,EAAQZ,EAAQuB,gBAAkB6C,EAAI,GAAKA,EAAI,GAAIF,EAAa,IAClFE,EAAI,IAAMA,EAAI,GAAG3E,OAAS,IAC1B2E,EAAI,GAAKA,EAAI,GAAG5B,OAAO,EAAG4B,EAAI,GAAG3E,OAAS,IAE9C+E,EAAUC,SAAWhB,EAAmBW,EAAI,GAAIpE,GAChDkE,EAAYQ,SAASF,OAClB,CACH,IAAMA,EAAY,IAAI5D,EAAQZ,EAAQuB,gBAAkB6C,EAAI,GAAKA,EAAI,GAAIF,EAAahC,EAAgBkC,EAAI,IAAKpE,IAC/GwE,EAAUC,SAAWhB,EAAmBW,EAAI,GAAIpE,GAChDkE,EAAYQ,SAASF,GACrBN,EAAcM,EAGlBJ,EAAMC,EACNA,EAAUF,EAAShF,KAAK6E,GAG5B,OAAOC,iCC/FX,IAAMU,EAAahI,EAAQ,GACrBiI,EAAejI,EAAQ,GACvBkI,EAAYlI,EAAQ,GACpBoD,EAAepD,EAAQ,GAAUoD,aAEvClD,EAAQiI,MAAQ,SAASd,EAAShE,GAE9B,OADAA,EAAUD,EAAaC,EAAS6E,EAAU5E,eAAgB4E,EAAU3E,OAC7DyE,EAAWI,cAAcH,EAAab,gBAAgBC,EAAShE,GAAUA,IAEpFnD,EAAQmI,cAAgBrI,EAAQ,GAAmBsI,aACnDpI,EAAQkH,gBAAkBa,EAAab,gBACvClH,EAAQkI,cAAgBJ,EAAWI,cACnClI,EAAQqI,oBAAsBvI,EAAQ,GAAmBuI,oBACzDrI,EAAQsI,SAAWxI,EAAQ,GAAewI,SAC1CtI,EAAQuI,UAAYzI,EAAQ,GAC5BE,EAAQwI,YAAc,SAAUrB,EAAQsB,EAAOtF,GAC3C,OAAOnD,EAAQmI,cAAcnI,EAAQkH,gBAAgBC,EAAQhE,GAAUsF,EAAQtF,kCChBnF,IAAMW,EAAOhE,EAAQ,GAmCrBE,EAAQkI,cAjCa,SAAfA,EAAwBQ,EAAMvF,GAChC,IAAMwF,KAGN,KAAMD,EAAKE,QAAW9E,EAAKrB,cAAciG,EAAKE,QAAaF,EAAKd,WAAY9D,EAAKrB,cAAciG,EAAKd,WAChG,OAAO9D,EAAKvB,QAAQmG,EAAKpD,KAAOoD,EAAKpD,IAAM,GAEvCxB,EAAKvB,QAAQmG,EAAKpD,OACQ,iBAAboD,EAAKpD,KAAkC,KAAboD,EAAKpD,KAAcoD,EAAKpD,MAAQnC,EAAQ8B,qBAC3E0D,EAAKxF,EAAQqB,cAAgBkE,EAAKpD,KAK9CxB,EAAKjB,MAAM8F,EAAMD,EAAKd,UAGtB,IADA,IAAMjF,EAAO/B,OAAO+B,KAAK+F,EAAKE,OACrBhF,EAAQ,EAAGA,EAAQjB,EAAKC,OAAQgB,IAAS,CAC9C,IAAIiC,EAAUlD,EAAKiB,GACnB,GAAI8E,EAAKE,MAAM/C,IAAY6C,EAAKE,MAAM/C,GAASjD,OAAS,EAEpD,IAAK,IAAI2E,KADToB,EAAK9C,MACW6C,EAAKE,MAAM/C,GACvB8C,EAAK9C,GAAShC,KAAMqE,EAAcQ,EAAKE,MAAM/C,GAAS0B,GAAMpE,SAGhEwF,EAAK9C,GAAWqC,EAAcQ,EAAKE,MAAM/C,GAAS,GAAI1C,GAK9D,OAAOwF,iCChCX1I,EAAOD,QAAU,SAAS6F,EAAS6B,EAAQpC,GACvCuD,KAAKhD,QAAUA,EACfgD,KAAKnB,OAASA,EACdmB,KAAKD,SACLC,KAAKjB,YACLiB,KAAKvD,IAAMA,EACXuD,KAAKhB,SAAW,SAASe,GACjBC,KAAKD,MAAMA,EAAM/C,SACjBgD,KAAKD,MAAMA,EAAM/C,SAAShC,KAAK+E,GAE/BC,KAAKD,MAAMA,EAAM/C,UAAY+C,mCCXzC,IAAME,EAAO,SAAS/F,GAClB,OAAO0D,OAAOsC,aAAahG,IAGzBiG,GACFC,QAAUH,EAAK,KACfI,YAAcJ,EAAK,KACnBK,aAAeL,EAAK,KACpBM,iBAAmBN,EAAK,KAExBO,UAAYP,EAAK,KACjBQ,WAAaR,EAAK,KAElBS,YAAcT,EAAK,KAEnBU,SAAUV,EAAK,KACfW,SAAUX,EAAK,KACfY,SAAUZ,EAAK,MAGba,GACFX,EAAMC,QACND,EAAMG,aACNH,EAAME,YACNF,EAAMI,iBACNJ,EAAMO,YACNP,EAAMK,UACNL,EAAMM,WACNN,EAAMU,SACNV,EAAMQ,SACNR,EAAMS,UAGJG,EAAK,SAALA,EAAclB,EAAMmB,EAAU1G,GAChC,GAAwB,iBAAb0G,EACP,OAAInB,GAAQA,EAAK,SAAsBnF,IAAhBmF,EAAK,GAAGpD,IACpBrC,EAASyF,EAAK,GAAGpD,IAAKuE,GAEtB5G,EAASyF,EAAMmB,GAG1B,IAAMC,EA2Ed,SAAiBnB,GACb,YAAapF,IAAToF,EACOK,EAAME,YACG,OAATP,EACAK,EAAMC,UACNN,EAAKC,OAA4C,IAAnChI,OAAO+B,KAAKgG,EAAKC,OAAOhG,UAAkB+F,EAAKf,UAAkD,IAAtChH,OAAO+B,KAAKgG,EAAKf,UAAUhF,UACpGoG,EAAMK,UAjFQU,CAAQrB,GAC7B,IAAqB,IAAjBoB,EAAuB,CACvB,IAAIE,EAAM,GACV,GAAIC,MAAMC,QAAQL,GAAW,CAEzBG,GAAOhB,EAAMS,SACb,IAAMU,EAAaN,EAAS,GAEtBO,EAAU1B,EAAK9F,OAErB,GAA0B,iBAAfuH,EACP,IAAK,IAAIE,EAAQ,EAAGA,EAAQD,EAASC,IAAS,CAC1C,IAAMrJ,EAAIiC,EAASyF,EAAK2B,GAAO/E,IAAK6E,GACpCH,EAAMM,EAAaN,EAAKhJ,QAG5B,IAAK,IAAIqJ,EAAQ,EAAGA,EAAQD,EAASC,IAAS,CAC1C,IAAMrJ,EAAI4I,EAAGlB,EAAK2B,GAAQF,EAAYhH,GACtC6G,EAAMM,EAAaN,EAAKhJ,GAGhCgJ,GAAOhB,EAAMU,aACV,CACHM,GAAOhB,EAAMQ,SACb,IAAM7G,EAAO/B,OAAO+B,KAAKkH,GAIzB,IAAK,IAAI3J,KAHL+J,MAAMC,QAAQxB,KACdA,EAAOA,EAAK,IAEF/F,EAAM,CAChB,IAAMlB,EAAMkB,EAAKzC,GAIbc,OAAC,EAEDA,GADCmC,EAAQsB,kBAAoBiE,EAAKd,UAAYc,EAAKd,SAASnG,GACxDmI,EAAGlB,EAAKd,SAASnG,GAAMoI,EAASpI,GAAM0B,GACnC1B,IAAQ0B,EAAQqB,aACnBoF,EAAGlB,EAAKpD,IAAKuE,EAASpI,GAAM0B,GAE5ByG,EAAGlB,EAAKE,MAAMnH,GAAMoI,EAASpI,GAAM0B,GAE3C6G,EAAMM,EAAaN,EAAKhJ,IAGhC,OAAOgJ,EAEP,OAAOF,GAKb7G,EAAW,SAASF,GACtB,OAAQA,GACJ,UAAKQ,EACD,OAAOyF,EAAMI,iBACjB,KAAK,KACD,OAAOJ,EAAMG,aACjB,IAAK,GACD,OAAOH,EAAMM,WACjB,QACI,OAAOvG,IAIbuH,EAAe,SAASN,EAAKhJ,GAI/B,OAHKuJ,EAAUvJ,EAAE,KAAQuJ,EAAUP,EAAIA,EAAIpH,OAAS,MAChDoH,GAAOhB,EAAMO,aAEVS,EAAMhJ,GAGXuJ,EAAY,SAASC,GACvB,OAAiC,IAA1Bb,EAAStD,QAAQmE,IAe5B,IAAMC,EAAM3K,EAAQ,GACdoD,EAAepD,EAAQ,GAAUoD,aAOvClD,EAAQoI,aALa,SAASM,EAAMmB,EAAU1G,GAE1C,OADAA,EAAUD,EAAaC,EAAQsH,EAAIrH,eAAeqH,EAAIpH,OAC/CuG,EAAGlB,EAAMmB,EAAU1G,kCCpI9B,IAAMW,EAAOhE,EAAQ,GACfoD,EAAepD,EAAQ,GAAUoD,aACjCuH,EAAM3K,EAAQ,GAUd4K,EAAc,SAAdA,EAAuBhC,EAAMvF,EAAQwH,GAMvC,IALA,IAAIhC,EAAO,IAGLhG,EAAO/B,OAAO+B,KAAK+F,EAAKE,OAErBhF,EAAQ,EAAGA,EAAQjB,EAAKC,OAAQgB,IAAS,CAC9C,IAAIiC,EAAUlD,EAAKiB,GACnB,GAAI8E,EAAKE,MAAM/C,IAAY6C,EAAKE,MAAM/C,GAASjD,OAAS,EAAG,CAEvD,IAAK,IAAI2E,KADToB,GAAS,IAAO9C,EAAU,SACV6C,EAAKE,MAAM/C,GACvB8C,GAAQ+B,EAAYhC,EAAKE,MAAM/C,GAAS0B,GAAMpE,GAAW,MAE7DwF,EAAOA,EAAKhD,OAAO,EAAEgD,EAAK/F,OAAO,GAAK,WAEtC+F,GAAQ,IAAM9C,EAAU,OAAU6E,EAAYhC,EAAKE,MAAM/C,GAAS,GAAI1C,GAAW,KAKzF,OAFAW,EAAKjB,MAAM8F,EAAMD,EAAKd,UAElB9D,EAAKrB,cAAckG,GACZ7E,EAAKvB,QAAQmG,EAAKpD,KAAOoD,EAAKpD,IAAM,IAEvCxB,EAAKvB,QAAQmG,EAAKpD,OACQ,iBAAboD,EAAKpD,KAAkC,KAAboD,EAAKpD,KAAcoD,EAAKpD,MAAQnC,EAAQ8B,qBAC3E0D,GAAQ,IAAOxF,EAAQqB,aAAc,OAWrD,SAAmBhC,GACf,OAAS,IAANA,IAAoB,IAANA,GAAgB4D,MAAM5D,GAG5B,IAAOA,EAAI,IAFXA,EAbgDoI,CAAUlC,EAAKpD,MAK/C,MAAxBqD,EAAKA,EAAK/F,OAAO,KAChB+F,EAAOA,EAAKhD,OAAO,EAAEgD,EAAK/F,OAAO,IAE9B+F,EAAO,MAelB3I,EAAQqI,oBAvDoB,SAASK,EAAMvF,GAIvC,OAHAA,EAAUD,EAAaC,EAAQsH,EAAIrH,eAAeqH,EAAIpH,QAE9CwH,SAAW1H,EAAQ0H,UAAY,GAChCH,EAAYhC,EAAMvF,EAAQ,kCCTrC,IAAMW,EAAOhE,EAAQ,GAEfsD,GACFuB,wBAAwB,EACxBO,YAAc,UAGZ7B,GAAS,yBAA0B,eAkIzC,SAASyH,EAAO3D,EAASjH,GAErB,IADA,IAAI6K,EAAQ7K,EACLA,EAAIiH,EAAQvE,OAAQ1C,IACvB,GAAkB,KAAdiH,EAAQjH,IAA2B,KAAdiH,EAAQjH,QAAjC,CACI,IAAI2F,EAAUsB,EAAQxB,OAAOoF,EAAO7K,EAAI6K,GACxC,GAAI7K,EAAI,GAAiB,QAAZ2F,EACT,OAAQmF,KAAMC,KAAM,aAAcC,IAAK,+DACpC,GAAkB,KAAd/D,EAAQjH,IAA+B,KAAlBiH,EAAQjH,EAAI,GAAW,CAEnDA,IACA,OAMZ,OAAOA,EAGX,SAASiL,EAAoBhE,EAASjH,GAClC,GAAIiH,EAAQvE,OAAS1C,EAAI,GAAwB,MAAnBiH,EAAQjH,EAAI,IAAiC,MAAnBiH,EAAQjH,EAAI,IAChE,IAAKA,GAAK,EAAGA,EAAIiH,EAAQvE,OAAQ1C,IAC7B,GAAmB,MAAfiH,EAAQjH,IAAiC,MAAnBiH,EAAQjH,EAAI,IAAiC,MAAnBiH,EAAQjH,EAAI,GAAY,CACxEA,GAAK,EACL,YAGL,GAAIiH,EAAQvE,OAAS1C,EAAI,GACF,MAAnBiH,EAAQjH,EAAI,IACO,MAAnBiH,EAAQjH,EAAI,IACO,MAAnBiH,EAAQjH,EAAI,IACO,MAAnBiH,EAAQjH,EAAI,IACO,MAAnBiH,EAAQjH,EAAI,IACO,MAAnBiH,EAAQjH,EAAI,IACO,MAAnBiH,EAAQjH,EAAI,GAAY,CAC/B,IAAIkL,EAAqB,EACzB,IAAKlL,GAAK,EAAGA,EAAIiH,EAAQvE,OAAQ1C,IAC7B,GAAmB,MAAfiH,EAAQjH,GAAakL,SACpB,GAAmB,MAAfjE,EAAQjH,IAEc,MAD3BkL,EAEI,WAIT,GAAIjE,EAAQvE,OAAS1C,EAAI,GACF,MAAnBiH,EAAQjH,EAAI,IACO,MAAnBiH,EAAQjH,EAAI,IACO,MAAnBiH,EAAQjH,EAAI,IACO,MAAnBiH,EAAQjH,EAAI,IACO,MAAnBiH,EAAQjH,EAAI,IACO,MAAnBiH,EAAQjH,EAAI,IACO,MAAnBiH,EAAQjH,EAAI,GAEnB,IAAKA,GAAK,EAAGA,EAAIiH,EAAQvE,OAAQ1C,IAC7B,GAAmB,MAAfiH,EAAQjH,IAAiC,MAAnBiH,EAAQjH,EAAI,IAAiC,MAAnBiH,EAAQjH,EAAI,GAAY,CACxEA,GAAK,EACL,MAKZ,OAAOA,EA7LXF,EAAQsI,SAAW,SAASnB,EAAShE,GACjCA,EAAUW,EAAKZ,aAAaC,EAAQC,EAAeC,GAMnD,IAAMyC,KACFuF,GAAW,EACI,WAAflE,EAAQ,KACVA,EAAUA,EAAQxB,OAAO,IAI3B,IAFA,IAAM2F,EAAe,IAAI3E,OAAO,oBAAoBG,QAAQ,KAAM,IAAM3D,EAAQ+B,cAC1EqG,EAAc,IAAI5E,OAAO,uBAAuBG,QAAQ,MAAO,KAAO3D,EAAQ+B,cAC3EhF,EAAI,EAAGA,EAAIiH,EAAQvE,OAAQ1C,IAAK,CAErC,GAAmB,MAAfiH,EAAQjH,GAyFL,CACH,GAAmB,MAAfiH,EAAQjH,IAA6B,OAAfiH,EAAQjH,IAA8B,OAAfiH,EAAQjH,IAA8B,OAAfiH,EAAQjH,GAC5E,SAEJ,OAAQ8K,KAAMC,KAAM,cAAeC,IAAK,QAAU/D,EAAQjH,GAAK,uBAzF/D,GAAmB,MAAfiH,IADJjH,IAGI,IADAA,EAAI4K,EAAO3D,IAAWjH,IAChB8K,IACF,OAAO9K,MAER,IAAmB,MAAfiH,EAAQjH,GAAY,CAC3BA,EAAIiL,EAAoBhE,EAASjH,GACjC,SAEA,IAAIsL,GAAa,EACE,MAAfrE,EAAQjH,KACRsL,GAAa,EACbtL,KAIJ,IADA,IAAIuL,EAAU,GACPvL,EAAIiH,EAAQvE,QACG,MAAfuE,EAAQjH,IACO,MAAfiH,EAAQjH,IACO,OAAfiH,EAAQjH,GAAaA,IAExBuL,GAAWtE,EAAQjH,GAKvB,GAAoC,OAHpCuL,EAAUA,EAAQlG,QAGNkG,EAAQ7I,OAAS,GAAY,CACrC6I,EAAUA,EAAQC,UAAU,EAAGD,EAAQ7I,OAAS,GAChD,SAEJ,IAAK+I,EAAgBF,EAASF,GAC1B,OAAQP,KAAMC,KAAM,aAAcC,IAAK,OAASO,EAAU,yBAG9D,IAAMG,EAASC,EAAiB1E,EAASjH,GACzC,IAAe,IAAX0L,EACA,OAAQZ,KAAMC,KAAM,cAAeC,IAAK,kBAAoBO,EAAU,qBAE1E,IAAI5E,EAAU+E,EAAOzK,MAGrB,GAFAjB,EAAI0L,EAAOhI,MAEyB,MAAhCiD,EAAQA,EAAQjE,OAAS,GAAY,CAErC,IAAMkJ,EAAUC,EADhBlF,EAAUA,EAAQ6E,UAAU,EAAG7E,EAAQjE,OAAS,GACCO,EAASmI,GAC1D,IAAgB,IAAZQ,EAIA,OAAOA,EAHPT,GAAW,OAKZ,GAAIG,EAAY,CACnB,GAAI3E,EAAQtB,OAAO3C,OAAS,EACxB,OAAQoI,KAAMC,KAAM,aAAcC,IAAK,eAAiBO,EAAU,gDAElE,IAAMO,EAAMlG,EAAKmG,MACjB,GAAIR,IAAYO,EACZ,OAAQhB,KAAMC,KAAM,aAAcC,IAAK,eAAiBc,EAAM,2BAA6BP,EAAU,UAG1G,CACH,IAAMK,EAAUC,EAAwBlF,EAAS1D,EAASmI,GAC1D,IAAgB,IAAZQ,EACA,OAAOA,EAEXhG,EAAKjC,KAAK4H,GACVJ,GAAW,EAKf,IAAKnL,IAAKA,EAAIiH,EAAQvE,OAAQ1C,IAC1B,GAAmB,MAAfiH,EAAQjH,GAAY,CACpB,GAAuB,MAAnBiH,EAAQjH,EAAI,GAAY,CAExBA,EAAIiL,EAAoBhE,IADxBjH,GAEA,SAEA,MAIO,MAAfiH,EAAQjH,IACRA,KAWhB,OAAKmL,IAEMvF,EAAKlD,OAAS,KACboI,KAAMC,KAAM,aAAcC,IAAK,WAAagB,KAAKC,UAAUrG,EAAM,KAAM,GAAGgB,QAAQ,SAAU,IAAM,aAFlGkE,KAAMC,KAAM,aAAcC,IAAK,yBA8E/C,IAAIkB,EAAc,IACdC,EAAc,IAOlB,SAASR,EAAiB1E,EAASjH,GAG/B,IAFA,IAAI2G,EAAU,GACVyF,EAAY,GACTpM,EAAIiH,EAAQvE,OAAQ1C,IAAK,CAC5B,GAAIiH,EAAQjH,KAAOkM,GAAejF,EAAQjH,KAAOmM,EAC7C,GAAkB,KAAdC,EACAA,EAAYnF,EAAQjH,OACjB,IAAIoM,IAAcnF,EAAQjH,GAE7B,SAEAoM,EAAY,QAEb,GAAmB,MAAfnF,EAAQjH,IACG,KAAdoM,EACA,MAGRzF,GAAWM,EAAQjH,GAEvB,MAAkB,KAAdoM,IAIInL,MAAO0F,EAASjD,MAAO1D,GAMnC,IAAMqM,EAAoB,IAAI5F,OAAO,0DAA2D,KAIhG,SAASoF,EAAwBlF,EAAS1D,EAASmI,GAQ/C,IAHA,IAAM5H,EAAUI,EAAKL,cAAcoD,EAAS0F,GACtCC,KAEGtM,EAAI,EAAGA,EAAIwD,EAAQd,OAAQ1C,IAAK,CAGrC,GAA6B,IAAzBwD,EAAQxD,GAAG,GAAG0C,OACd,OAAQoI,KAAMC,KAAM,cAAeC,IAAK,aAAexH,EAAQxD,GAAG,GAAK,+BACpE,QAAsBqD,IAAlBG,EAAQxD,GAAG,KAAqBiD,EAAQwB,uBAC/C,OAAQqG,KAAMC,KAAM,cAAeC,IAAK,qBAAuBxH,EAAQxD,GAAG,GAAK,qBAKnF,IAAM8G,EAAWtD,EAAQxD,GAAG,GAC5B,IAAKuM,EAAiBzF,EAAUsE,GAC5B,OAAQN,KAAMC,KAAM,cAAeC,IAAK,aAAelE,EAAW,yBAEtE,GAAKwF,EAAUzK,eAAeiF,GAG1B,OAAQgE,KAAMC,KAAM,cAAeC,IAAK,aAAelE,EAAW,kBAFlEwF,EAAUxF,GAAY,EAM9B,OAAO,EAMX,SAASyF,EAAiBzF,EAAUsE,GAEhC,OAAOxH,EAAK5B,UAAU8E,EAAUsE,GAMpC,SAASK,EAAgB9F,EAAS0F,GAG9B,OAAQzH,EAAKN,aAAaqC,EAAS0F,kCCnSvC,IAAMrI,EAAepD,EAAQ,GAAUoD,aAEjCE,GACFkB,oBAAqB,KACrBC,cAAc,EACdC,aAAc,QACdC,kBAAkB,EAClBO,cAAc,EACdC,kBAAmB,MACnByH,QAAQ,EACR7B,SAAU,KACV8B,kBAAkB,EAClBxH,kBAAmB,SAASpC,GAAI,OAAOA,GACvCqC,mBAAoB,SAASrC,GAAI,OAAOA,IAGtCM,GACF,sBACA,eACA,eACA,mBACA,eACA,oBACA,SACA,WACA,mBACA,oBACA,sBAGJ,SAASuJ,EAAOzJ,GACZ0F,KAAK1F,QAAUD,EAAaC,EAAQC,EAAeC,GAC/CwF,KAAK1F,QAAQsB,kBAAoBoE,KAAK1F,QAAQoB,aAC9CsE,KAAKgE,YAAc,WAAkB,OAAO,IAE5ChE,KAAKiE,cAAgBjE,KAAK1F,QAAQmB,oBAAoB1B,OACtDiG,KAAKgE,YAAcA,GAEnBhE,KAAK1F,QAAQ6B,aACb6D,KAAKkE,QAAUA,EAEflE,KAAKkE,QAAU,WAAkB,OAAO,GAE5ClE,KAAKmE,gBAAkBA,EACvBnE,KAAKoE,gBAAkBA,EAEnBpE,KAAK1F,QAAQuJ,QACb7D,KAAKqE,UAAYA,EACjBrE,KAAKsE,WAAa,MAClBtE,KAAKuE,QAAU,OAEfvE,KAAKqE,UAAY,WAAa,MAAO,IACrCrE,KAAKsE,WAAa,IAClBtE,KAAKuE,QAAU,IAGfvE,KAAK1F,QAAQwJ,kBACb9D,KAAKwE,cAAgBC,EACrBzE,KAAK0E,aAAeC,IAEpB3E,KAAKwE,cAAgBI,EACrB5E,KAAK0E,aAAeG,GAGxB7E,KAAK4E,iBAAmBA,EACxB5E,KAAK6E,gBAAkBA,EAgF3B,SAASV,EAAgBhD,EAAK2D,GAE1B,OADA3D,EAAMnB,KAAK1F,QAAQgC,kBAAkB,GAAK6E,GACH,KAAnCnB,KAAK1F,QAAQ8B,mBAAoC,KAAR+E,EAClCA,EAAM,YAAc2D,EAAQ,KAAO9E,KAAKsE,WAExCnD,EAAIlD,QAAQ+B,KAAK1F,QAAQ8B,kBAAmB,YAAc0I,EAAQ,KAAO9E,KAAKsE,YAI7F,SAASF,EAAgBjD,EAAK2D,GAE1B,GADA3D,EAAMnB,KAAK1F,QAAQgC,kBAAkB,GAAK6E,GACH,KAAnCnB,KAAK1F,QAAQ8B,mBAAoC,KAAR+E,EACzC,OAAOA,EAAM,YAAc2D,EAAMC,KAAK,gBAAkB,KAAO/E,KAAKsE,WAEpE,IAAK,IAAI3K,KAAKmL,EACV3D,EAAMA,EAAIlD,QAAQ+B,KAAK1F,QAAQ8B,kBAAmB,YAAc0I,EAAMnL,GAAK,OAE/E,OAAOwH,EAAMnB,KAAKuE,QAI1B,SAASM,EAAgBpI,EAAK7D,EAAKoF,EAAS8D,GAC1C,OAAI9D,IAAYvB,EAAIuI,SAAS,KACpBhF,KAAKqE,UAAUvC,GACd,IAAMlJ,EAAMoF,EACZ,IACAvB,EAGA,KAAO7D,EAAMoH,KAAKsE,WAEnBtE,KAAKqE,UAAUvC,GACd,IAAMlJ,EAAMoF,EACZgC,KAAKsE,WACL7H,EAEAuD,KAAKqE,UAAUvC,GACf,KAAOlJ,EAAMoH,KAAKsE,WAI9B,SAASK,EAAkBlI,EAAK7D,EAAKoF,EAAS8D,GAC1C,MAAY,KAARrF,EACOuD,KAAK6E,gBAAgBpI,EAAK7D,EAAKoF,EAAS8D,GAExC9B,KAAKqE,UAAUvC,GACb,IAAMlJ,EAAMoF,EACZ,IACAgC,KAAKsE,WAKtB,SAASM,EAAiBnI,EAAK7D,EAAKoF,EAAS8D,GACzC,OAAO9B,KAAKqE,UAAUvC,GAAS,IAAMlJ,EAAMoF,EAAU,IAAMgC,KAAK1F,QAAQgC,kBAAkB,GAAKG,GAAO,KAAO7D,EAAMoH,KAAKsE,WAG5H,SAASG,EAAmBhI,EAAK7D,EAAKoF,EAAS8D,GAC3C,MAAY,KAARrF,EACOuD,KAAK4E,iBAAiBnI,EAAK7D,EAAKoF,EAAS8D,GAEzC9B,KAAKqE,UAAUvC,GAAS,IAAMlJ,EAAMoF,EAAU,IAAMgC,KAAKsE,WAIxE,SAASD,EAAUvC,GACf,OAAO9B,KAAK1F,QAAQ0H,SAASiD,OAAOnD,GAGxC,SAASkC,EAAYpM,GACjB,QAAIA,EAAKsN,WAAWlF,KAAK1F,QAAQmB,sBACtB7D,EAAKkF,OAAOkD,KAAKiE,eAMhC,SAASC,EAAQtM,GACb,OAAOA,IAASoI,KAAK1F,QAAQ6B,aA1JjC4H,EAAO9K,UAAUmG,MAAQ,SAASU,GAC9B,OAAOE,KAAKmF,IAAIrF,EAAM,GAAGrD,KAG7BsH,EAAO9K,UAAUkM,IAAM,SAASrF,EAAMgC,GAKlC,IAJA,IAAI9D,EAAU,GACVvB,EAAM,GACJ3C,EAAO/B,OAAO+B,KAAKgG,GACnB3F,EAAML,EAAKC,OACR1C,EAAI,EAAGA,EAAI8C,EAAK9C,IAAK,CAC1B,IAAMuB,EAAMkB,EAAKzC,GACjB,QAAyB,IAAdyI,EAAKlH,SAEV,GAAkB,OAAdkH,EAAKlH,GACX6D,GAAOuD,KAAKqE,UAAUvC,GAAS,IAAMlJ,EAAM,IAAMoH,KAAKsE,gBACpD,GAAyB,iBAAdxE,EAAKlH,GAAmB,CACrC,IAAMwM,EAAOpF,KAAKgE,YAAYpL,GAC1BwM,EACApH,GAAW,IAAMoH,EAAO,KAASpF,KAAK1F,QAAQiC,mBAAmB,GAAKuD,EAAKlH,IAAQ,IAC5EoH,KAAKkE,QAAQtL,GAChBkH,EAAKE,KAAK1F,QAAQqB,cAClBc,GAAOuD,KAAKmE,gBAAgBrE,EAAKE,KAAK1F,QAAQqB,cAAemE,EAAKlH,IAElE6D,GAAOuD,KAAKmE,gBAAgB,GAAIrE,EAAKlH,IAGrCA,IAAQoH,KAAK1F,QAAQqB,aACjBmE,EAAKE,KAAK1F,QAAQ6B,gBAGlBM,GAAQuD,KAAK1F,QAAQgC,kBAAkB,GAAKwD,EAAKlH,KAGrD6D,GAAOuD,KAAKwE,cAAc1E,EAAKlH,GAAMA,EAAK,GAAIkJ,QAGnD,GAAIV,MAAMC,QAAQvB,EAAKlH,IAC1B,GAAIoH,KAAKkE,QAAQtL,GACf6D,GAAOuD,KAAKqE,UAAUvC,GAChBhC,EAAKE,KAAK1F,QAAQqB,cACpBc,GAAOuD,KAAKoE,gBAAgBtE,EAAKE,KAAK1F,QAAQqB,cAAemE,EAAKlH,IAElE6D,GAAOuD,KAAKoE,gBAAgB,GAAItE,EAAKlH,SAIvC,IADA,IAAMyM,EAASvF,EAAKlH,GAAKmB,OAChBuL,EAAI,EAAGA,EAAID,EAAQC,IAAK,CAC7B,IAAMC,EAAOzF,EAAKlH,GAAK0M,GACvB,QAAoB,IAATC,QAEL,GAAY,OAATA,EACL9I,GAAOuD,KAAKqE,UAAUvC,GAAS,IAAMlJ,EAAM,IAAMoH,KAAKsE,gBACpD,GAAoB,iBAATiB,EAAmB,CAChC,IAAMxC,EAAS/C,KAAKmF,IAAII,EAAMzD,EAAQ,GACtCrF,GAAOuD,KAAK0E,aAAa3B,EAAOtG,IAAK7D,EAAKmK,EAAO/E,QAAS8D,QAE1DrF,GAAOuD,KAAKwE,cAAce,EAAM3M,EAAK,GAAIkJ,QAKrD,GAAI9B,KAAK1F,QAAQoB,cAAgB9C,IAAQoH,KAAK1F,QAAQoB,aAGlD,IAFA,IAAM8J,EAAKzN,OAAO+B,KAAKgG,EAAKlH,IACtB6M,EAAID,EAAGzL,OACJuL,EAAI,EAAGA,EAAIG,EAAGH,IACnBtH,GAAW,IAAMwH,EAAGF,GAAK,KAAQtF,KAAK1F,QAAQgC,kBAAkB,GAAKwD,EAAKlH,GAAK4M,EAAGF,KAAO,QAE1F,CACH,IAAMvC,EAAS/C,KAAKmF,IAAIrF,EAAKlH,GAAMkJ,EAAQ,GAC3CrF,GAAOuD,KAAK0E,aAAa3B,EAAOtG,IAAK7D,EAAKmK,EAAO/E,QAAS8D,IAItE,OAAQ9D,QAASA,EAASvB,IAAKA,IAwFnCrF,EAAOD,QAAU4M","file":"./lib/parser.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","\"use strict\";\n\nconst getAllMatches = function(string, regex) {\n    const matches = [];\n    let match = regex.exec(string);\n    while (match) {\n        const allmatches = [];\n        const len = match.length;\n        for (let index = 0; index < len; index++) {\n            allmatches.push(match[index]);\n        }\n        matches.push(allmatches);\n        match = regex.exec(string);\n    }\n    return matches;\n};\n\nconst doesMatch = function(string, regex) {\n    const match = regex.exec(string);\n    return !(match === null || typeof match === \"undefined\");\n};\n\nconst doesNotMatch = function(string, regex) {\n    return !doesMatch(string, regex);\n};\n\nexports.isExist = function(v) {\n    return typeof v !== \"undefined\";\n};\n\nexports.isEmptyObject = function(obj) {\n    return Object.keys(obj).length === 0;\n};\n\n/**\n * Copy all the properties of a into b.\n * @param {*} target\n * @param {*} a\n */\nexports.merge = function(target, a) {\n    if (a) {\n        const keys = Object.keys(a); // will return an array of own properties\n        const len = keys.length; //don't make it inline\n        for (let i = 0; i < len; i++) {\n            target[keys[i]] = a[keys[i]];\n        }\n    }\n};\n/* exports.merge =function (b,a){\n  return Object.assign(b,a);\n} */\n\nexports.getValue = function(v) {\n    if (exports.isExist(v)) {\n        return v;\n    } else {\n        return \"\";\n    }\n};\n\n// const fakeCall = function(a) {return a;};\n// const fakeCallNoReturn = function() {};\n\nexports.buildOptions = function(options,defaultOptions,props) {\n    var newOptions = {};\n    if (!options) {\n        return defaultOptions; //if there are not options\n    }\n\n    for (let i = 0; i < props.length; i++) {\n        if ( options[props[i]] !== undefined) {\n            newOptions[props[i]] = options[props[i]];\n        }else{\n            newOptions[props[i]] = defaultOptions[props[i]];\n        }\n    }\n    return newOptions;\n};\n\nexports.doesMatch = doesMatch;\nexports.doesNotMatch = doesNotMatch;\nexports.getAllMatches = getAllMatches;\n","\"use strict\";\n\nconst util = require(\"./util\");\nconst buildOptions = require(\"./util\").buildOptions;\nconst xmlNode = require(\"./xmlNode\");\nconst TagType = {\"OPENING\": 1, \"CLOSING\": 2, \"SELF\": 3, \"CDATA\": 4};\nlet regx = \"<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|(([\\\\w:\\\\-._]*:)?([\\\\w:\\\\-._]+))([^>]*)>|((\\\\/)(([\\\\w:\\\\-._]*:)?([\\\\w:\\\\-._]+))\\\\s*>))([^<]*)\";\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\n//treat cdata as a tag\n\nconst defaultOptions = {\n    attributeNamePrefix:    \"@_\",\n    attrNodeName:           false,\n    textNodeName:           \"#text\",\n    ignoreAttributes:       true,\n    ignoreNameSpace:        false,\n    allowBooleanAttributes: false,         //a tag can have attributes without any value\n    //ignoreRootElement : false,\n    parseNodeValue:         true,\n    parseAttributeValue:    false,\n    arrayMode:              false,\n    trimValues:             true,                                //Trim string values of tag and attributes\n    cdataTagName:           false,\n    cdataPositionChar:      \"\\\\c\",\n    localeRange:            \"\",\n    tagValueProcessor: function(a) {return a},\n    attrValueProcessor: function(a) {return a}\n    //decodeStrict: false,\n};\n\nexports.defaultOptions = defaultOptions;\n\nconst props = [\"attributeNamePrefix\", \"attrNodeName\", \"textNodeName\", \"ignoreAttributes\", \"ignoreNameSpace\", \"allowBooleanAttributes\", \"parseNodeValue\", \"parseAttributeValue\", \"arrayMode\", \"trimValues\", \"cdataTagName\", \"cdataPositionChar\", \"localeRange\", \"tagValueProcessor\", \"attrValueProcessor\", \"parseTrueNumberOnly\"];\nexports.props = props;\n\nconst getTraversalObj = function(xmlData, options) {\n    options = buildOptions(options,defaultOptions,props);\n    //xmlData = xmlData.replace(/\\r?\\n/g, \" \");//make it single line\n    xmlData = xmlData.replace(/<!--[\\s\\S]*?-->/g, \"\");//Remove  comments\n\n    const xmlObj = new xmlNode(\"!xml\");\n    let currentNode = xmlObj;\n\n    regx = regx.replace(/\\[\\\\w/g, \"[\" + options.localeRange + \"\\\\w\");\n    const tagsRegx = new RegExp(regx, \"g\");\n    let tag = tagsRegx.exec(xmlData);\n    let nextTag = tagsRegx.exec(xmlData);\n    while (tag) {\n        const tagType = checkForTagType(tag);\n\n        if (tagType === TagType.CLOSING) {\n            //add parsed data to parent node\n            if (currentNode.parent && tag[14]) {\n                currentNode.parent.val = util.getValue(currentNode.parent.val) + \"\" + processTagValue(tag[14], options);\n            }\n\n            currentNode = currentNode.parent;\n        } else if (tagType === TagType.CDATA) {\n            if (options.cdataTagName) {\n                //add cdata node\n                const childNode = new xmlNode(options.cdataTagName, currentNode, tag[3]);\n                childNode.attrsMap = buildAttributesMap(tag[8], options);\n                currentNode.addChild(childNode);\n                //for backtracking\n                currentNode.val = util.getValue(currentNode.val) + options.cdataPositionChar;\n                //add rest value to parent node\n                if (tag[14]) {\n                    currentNode.val += processTagValue(tag[14], options);\n                }\n            } else {\n                currentNode.val = (currentNode.val || \"\") + (tag[3] || \"\") + processTagValue(tag[14], options);\n            }\n        } else if (tagType === TagType.SELF) {\n            if (currentNode && tag[14]) {\n                currentNode.val = util.getValue(currentNode.val) + \"\" + processTagValue(tag[14], options);\n            }\n\n            const childNode = new xmlNode(options.ignoreNameSpace ? tag[7] : tag[5], currentNode, \"\");\n            if (tag[8] && tag[8].length > 1) {\n                tag[8] = tag[8].substr(0, tag[8].length - 1);\n            }\n            childNode.attrsMap = buildAttributesMap(tag[8], options);\n            currentNode.addChild(childNode);\n        } else {//TagType.OPENING\n            const childNode = new xmlNode(options.ignoreNameSpace ? tag[7] : tag[5], currentNode, processTagValue(tag[14], options));\n            childNode.attrsMap = buildAttributesMap(tag[8], options);\n            currentNode.addChild(childNode);\n            currentNode = childNode;\n        }\n\n        tag = nextTag;\n        nextTag = tagsRegx.exec(xmlData);\n    }\n\n    return xmlObj;\n};\n\nfunction processTagValue(val, options) {\n    if (val) {\n        if (options.trimValues) {\n            val = val.trim();\n        }\n        val = options.tagValueProcessor(val);\n        val = parseValue(val, options.parseNodeValue, options.parseTrueNumberOnly);\n    }\n\n    return val;\n}\n\nfunction checkForTagType(match) {\n    if (match[4] === \"]]>\") {\n        return TagType.CDATA;\n    } else if (match[10] === \"/\") {\n        return TagType.CLOSING;\n    } else if (typeof match[8] !== \"undefined\" && match[8].substr(match[8].length - 1) === \"/\") {\n        return TagType.SELF;\n    } else {\n        return TagType.OPENING;\n    }\n}\n\nfunction resolveNameSpace(tagname, options) {\n    if (options.ignoreNameSpace) {\n        const tags = tagname.split(\":\");\n        const prefix = tagname.charAt(0) === \"/\" ? \"/\" : \"\";\n        if (tags[0] === \"xmlns\") {\n            return \"\";\n        }\n        if (tags.length === 2) {\n            tagname = prefix + tags[1];\n        }\n    }\n    return tagname;\n}\n\nfunction parseValue(val, shouldParse, parseTrueNumberOnly) {\n    if (shouldParse && typeof val === \"string\") {\n        let parsed;\n        if (val.trim() === \"\" || isNaN(val)) {\n            parsed = val === \"true\" ? true : val === \"false\" ? false : val;\n        } else {\n            if(val.indexOf(\"0x\") !== -1){//support hexa decimal\n                parsed = Number.parseInt(val,16);\n            } else if (val.indexOf(\".\") !== -1) {\n                parsed = Number.parseFloat(val);\n            } else {\n                parsed = Number.parseInt(val, 10);\n            }\n            if(parseTrueNumberOnly){\n                parsed = String(parsed) === val ? parsed : val;\n                \n            }\n        }\n        return parsed;\n    } else {\n        if (util.isExist(val)) {\n            return val;\n        } else {\n            return \"\";\n        }\n    }\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp(\"([^\\\\s=]+)\\\\s*(=\\\\s*(['\\\"])(.*?)\\\\3)?\", \"g\");\n\nfunction buildAttributesMap(attrStr, options) {\n    if (!options.ignoreAttributes && typeof attrStr === \"string\") {\n        attrStr = attrStr.replace(/\\r?\\n/g, \" \");\n        //attrStr = attrStr || attrStr.trim();\n\n        const matches = util.getAllMatches(attrStr, attrsRegx);\n        const len = matches.length; //don't make it inline\n        const attrs = {};\n        for (let i = 0; i < len; i++) {\n            const attrName = resolveNameSpace(matches[i][1], options);\n            if (attrName.length) {\n                if (matches[i][4] !== undefined) {\n                    if (options.trimValues) {\n                        matches[i][4] = matches[i][4].trim();\n                    }\n                    matches[i][4] = options.attrValueProcessor(matches[i][4]);\n                    attrs[options.attributeNamePrefix + attrName] = parseValue(matches[i][4], options.parseAttributeValue, options.parseTrueNumberOnly);\n                } else if (options.allowBooleanAttributes) {\n                    attrs[options.attributeNamePrefix + attrName] = true;\n                }\n\n            }\n        }\n        if (!Object.keys(attrs).length) {\n            return;\n        }\n        if (options.attrNodeName) {\n            const attrCollection = {};\n            attrCollection[options.attrNodeName] = attrs;\n            return attrCollection;\n        }\n        return attrs;\n    }\n}\n\nexports.getTraversalObj = getTraversalObj;\n","\"use strict\";\n\nconst nodeToJson = require(\"./node2json\");\nconst xmlToNodeobj = require(\"./xmlstr2xmlnode\");\nconst x2xmlnode = require(\"./xmlstr2xmlnode\");\nconst buildOptions = require(\"./util\").buildOptions;\n\nexports.parse = function(xmlData, options) {\n    options = buildOptions(options, x2xmlnode.defaultOptions, x2xmlnode.props);\n    return nodeToJson.convertToJson(xmlToNodeobj.getTraversalObj(xmlData, options), options);\n};\nexports.convertTonimn = require(\"../src/nimndata\").convert2nimn;\nexports.getTraversalObj = xmlToNodeobj.getTraversalObj;\nexports.convertToJson = nodeToJson.convertToJson;\nexports.convertToJsonString = require(\"./node2json_str\").convertToJsonString;\nexports.validate = require(\"./validator\").validate;\nexports.j2xParser = require(\"./json2xml\");\nexports.parseToNimn = function (xmlData,schema,options){\n    return exports.convertTonimn(exports.getTraversalObj(xmlData,options), schema, options);\n};\n","\"use strict\";\n\nconst util = require(\"./util\");\n\nconst convertToJson =function(node, options) {\n    const jObj = {};\n\n    //when no child node or attr is present\n    if ((!node.child  ||  util.isEmptyObject(node.child)) && (!node.attrsMap || util.isEmptyObject(node.attrsMap))) {\n        return util.isExist(node.val) ? node.val : \"\";\n    } else { //otherwise create a textnode if node has some text\n        if (util.isExist(node.val)) {\n            if (!(typeof node.val === \"string\" && (node.val === \"\" || node.val === options.cdataPositionChar))) {\n                jObj[options.textNodeName] = node.val;\n            }\n        }\n    }\n\n    util.merge(jObj, node.attrsMap);\n\n    const keys = Object.keys(node.child);\n    for (let index = 0; index < keys.length; index++) {\n        var tagname = keys[index];\n        if (node.child[tagname] && node.child[tagname].length > 1) {\n            jObj[tagname] = [];\n            for (var tag in node.child[tagname]) {\n                jObj[tagname].push( convertToJson(node.child[tagname][tag], options) );\n            }\n        } else {\n            jObj[tagname] = convertToJson(node.child[tagname][0], options);\n        }\n    }\n    \n    //add value\n    return jObj;\n};\n\nexports.convertToJson = convertToJson;","\"use strict\";\n\nmodule.exports = function(tagname, parent, val) {\n    this.tagname = tagname;\n    this.parent = parent;\n    this.child = {};//child tags\n    this.attrsMap = {};//attributes map\n    this.val = val;//text only\n    this.addChild = function(child) {\n        if (this.child[child.tagname]) {//already presents\n            this.child[child.tagname].push(child);\n        } else {\n            this.child[child.tagname] = [child];\n        }\n    };\n};\n","\"use strict\";\nconst char = function(a) {\n    return String.fromCharCode(a);\n};\n\nconst chars = {\n    nilChar : char(176),\n    missingChar : char(201),\n    nilPremitive : char(175),\n    missingPremitive : char(200),\n\n    emptyChar : char(178),\n    emptyValue:  char(177),//empty Premitive\n    \n    boundryChar : char(179),\n    \n    objStart: char(198),\n    arrStart: char(204),\n    arrayEnd: char(185),\n};\n\nconst charsArr = [\n    chars.nilChar,\n    chars.nilPremitive,\n    chars.missingChar,\n    chars.missingPremitive,\n    chars.boundryChar,\n    chars.emptyChar,\n    chars.emptyValue,\n    chars.arrayEnd,\n    chars.objStart,\n    chars.arrStart\n];\n\nconst _e = function(node, e_schema, options) {\n    if (typeof e_schema === \"string\") {//premitive\n        if (node && node[0] && node[0].val !== undefined) {\n            return getValue(node[0].val, e_schema);\n        } else {\n            return getValue(node, e_schema);\n        }\n    } else {\n        const hasValidData = hasData(node);\n        if (hasValidData === true) {\n            let str = \"\";\n            if (Array.isArray(e_schema)) {\n                //attributes can't be repeated. hence check in children tags only\n                str += chars.arrStart;\n                const itemSchema = e_schema[0];\n                //var itemSchemaType = itemSchema;\n                const arr_len = node.length;\n\n                if (typeof itemSchema === \"string\") {\n                    for (let arr_i = 0; arr_i < arr_len; arr_i++) {\n                        const r = getValue(node[arr_i].val, itemSchema);\n                        str = processValue(str, r);\n                    }\n                } else {\n                    for (let arr_i = 0; arr_i < arr_len; arr_i++) {\n                        const r = _e(node[arr_i], itemSchema, options);\n                        str = processValue(str, r);\n                    }\n                }\n                str += chars.arrayEnd;//indicates that next item is not array item\n            } else {//object\n                str += chars.objStart;\n                const keys = Object.keys(e_schema);\n                if (Array.isArray(node)) {\n                    node = node[0];\n                }\n                for (let i in keys) {\n                    const key = keys[i];\n                    //a property defined in schema can be present either in attrsMap or children tags\n                    //options.textNodeName will not present in both maps, take it's value from val\n                    //options.attrNodeName will be present in attrsMap\n                    let r;\n                    if (!options.ignoreAttributes && node.attrsMap && node.attrsMap[key]) {\n                        r = _e(node.attrsMap[key], e_schema[key], options);\n                    } else if (key === options.textNodeName) {\n                        r = _e(node.val, e_schema[key], options);\n                    } else {\n                        r = _e(node.child[key], e_schema[key], options);\n                    }\n                    str = processValue(str, r);\n                }\n            }\n            return str;\n        } else {\n            return hasValidData;\n        }\n    }\n};\n\nconst getValue = function(a/*, type*/) {\n    switch (a) {\n        case undefined:\n            return chars.missingPremitive;\n        case null:\n            return chars.nilPremitive;\n        case \"\":\n            return chars.emptyValue;\n        default:\n            return a;\n    }\n};\n\nconst processValue = function(str, r) {\n    if (!isAppChar(r[0]) && !isAppChar(str[str.length - 1])) {\n        str += chars.boundryChar;\n    }\n    return str + r;\n};\n\nconst isAppChar = function(ch) {\n    return charsArr.indexOf(ch) !== -1;\n};\n\nfunction hasData(jObj) {\n    if (jObj === undefined) {\n        return chars.missingChar;\n    } else if (jObj === null) {\n        return chars.nilChar;\n    } else if (jObj.child && Object.keys(jObj.child).length === 0 && (!jObj.attrsMap || Object.keys(jObj.attrsMap).length === 0)) {\n        return chars.emptyChar;\n    } else {\n        return true;\n    }\n}\n\nconst x2j = require(\"./xmlstr2xmlnode\");\nconst buildOptions = require(\"./util\").buildOptions;\n\nconst convert2nimn = function(node, e_schema, options) {\n    options = buildOptions(options,x2j.defaultOptions,x2j.props);\n    return _e(node, e_schema, options);\n};\n\nexports.convert2nimn = convert2nimn;\n","\"use strict\";\n\nconst util = require(\"./util\");\nconst buildOptions = require(\"./util\").buildOptions;\nconst x2j = require(\"./xmlstr2xmlnode\");\n\n//TODO: do it later\nconst convertToJsonString = function(node, options) {\n    options = buildOptions(options,x2j.defaultOptions,x2j.props);\n\n    options.indentBy = options.indentBy || \"\";\n    return _cToJsonStr(node, options,0);\n}\n\nconst _cToJsonStr = function(node, options,level) {\n    let jObj = \"{\";\n\n    //traver through all the children\n    const keys = Object.keys(node.child);\n    \n    for (let index = 0; index < keys.length; index++) {\n        var tagname = keys[index];\n        if (node.child[tagname] && node.child[tagname].length > 1) {\n            jObj  += \"\\\"\" + tagname + \"\\\" : [ \";\n            for (var tag in node.child[tagname]) {\n                jObj += _cToJsonStr(node.child[tagname][tag], options) + \" , \";\n            }\n            jObj = jObj.substr(0,jObj.length-1) + \" ] \"; //remove extra comma in last\n        } else {\n            jObj += \"\\\"\" +tagname + \"\\\" : \" + _cToJsonStr(node.child[tagname][0], options) + \" ,\";\n        }\n    }\n    util.merge(jObj, node.attrsMap);\n    //add attrsMap as new children\n    if (util.isEmptyObject(jObj)) {\n        return util.isExist(node.val) ? node.val : \"\";\n    } else {\n        if (util.isExist(node.val)) {\n            if (!(typeof node.val === \"string\" && (node.val === \"\" || node.val === options.cdataPositionChar))) {\n                jObj += \"\\\"\" + options.textNodeName +\"\\\" : \" + stringval(node.val);\n            }\n        }\n    }\n    //add value\n    if(jObj[jObj.length-1] === \",\"){\n        jObj = jObj.substr(0,jObj.length-2);\n    }\n    return jObj + \"}\";\n};\n\nfunction stringval(v){\n    if(v === true || v === false || !isNaN(v)){\n        return v;\n    }else{\n        return \"\\\"\" + v + \"\\\"\";\n    }\n}\n\nfunction indentate(options, level) {\n    return options.indentBy.repeat(level);\n}\n\nexports.convertToJsonString = convertToJsonString;","\"use strict\";\n\nconst util = require(\"./util\");\n\nconst defaultOptions = {\n    allowBooleanAttributes: false,         //A tag can have attributes without any value\n    localeRange:  \"a-zA-Z\"\n};\n\nconst props = [\"allowBooleanAttributes\", \"localeRange\"];\n\n//const tagsPattern = new RegExp(\"<\\\\/?([\\\\w:\\\\-_\\.]+)\\\\s*\\/?>\",\"g\");\nexports.validate = function(xmlData, options) {\n    options = util.buildOptions(options,defaultOptions,props);\n\n    //xmlData = xmlData.replace(/(\\r\\n|\\n|\\r)/gm,\"\");//make it single line\n    //xmlData = xmlData.replace(/(^\\s*<\\?xml.*?\\?>)/g,\"\");//Remove XML starting tag\n    //xmlData = xmlData.replace(/(<!DOCTYPE[\\s\\w\\\"\\.\\/\\-\\:]+(\\[.*\\])*\\s*>)/g,\"\");//Remove DOCTYPE\n\n    const tags = [];\n    let tagFound = false;\n    if (xmlData[0] === \"\\ufeff\") {  // check for byte order mark (BOM)\n      xmlData = xmlData.substr(1);\n    }\n    const regxAttrName = new RegExp(\"^[_w][\\\\w\\\\-.:]*$\".replace(\"_w\", \"_\" + options.localeRange));\n    const regxTagName = new RegExp(\"^([w]|_)[\\\\w.\\\\-_:]*\".replace(\"([w\", \"([\" + options.localeRange));\n    for (let i = 0; i < xmlData.length; i++) {\n\n        if (xmlData[i] === \"<\") { //starting of tag\n            //read until you reach to '>' avoiding any '>' in attribute value\n\n            i++;\n            if (xmlData[i] === \"?\") {\n                i = readPI(xmlData, ++i);\n                if (i.err) {\n                    return i;\n                }\n            } else if (xmlData[i] === \"!\") {\n                i = readCommentAndCDATA(xmlData, i);\n                continue;\n            } else {\n                let closingTag = false;\n                if (xmlData[i] === \"/\") {//closing tag\n                    closingTag = true;\n                    i++;\n                }\n                //read tagname\n                let tagName = \"\";\n                for (; i < xmlData.length &&\n                       xmlData[i] !== \">\" &&\n                       xmlData[i] !== \" \" &&\n                       xmlData[i] !== \"\\t\"; i++) {\n\n                    tagName += xmlData[i];\n                }\n                tagName = tagName.trim();\n                //console.log(tagName);\n\n                if (tagName[tagName.length - 1] === \"/\") {//self closing tag without attributes\n                    tagName = tagName.substring(0, tagName.length - 1);\n                    continue;\n                }\n                if (!validateTagName(tagName, regxTagName)) {\n                    return {err: {code: \"InvalidTag\", msg: \"Tag \" + tagName + \" is an invalid name.\"}};\n                }\n\n                const result = readAttributeStr(xmlData, i);\n                if (result === false) {\n                    return {err: {code: \"InvalidAttr\", msg: \"Attributes for \" + tagName + \" have open quote\"}};\n                }\n                let attrStr = result.value;\n                i = result.index;\n\n                if (attrStr[attrStr.length - 1] === \"/\") {//self closing tag\n                    attrStr = attrStr.substring(0, attrStr.length - 1);\n                    const isValid = validateAttributeString(attrStr, options, regxAttrName);\n                    if (isValid === true) {\n                        tagFound = true;\n                        //continue; //text may presents after self closing tag\n                    } else {\n                        return isValid;\n                    }\n                } else if (closingTag) {\n                    if (attrStr.trim().length > 0) {\n                        return {err: {code: \"InvalidTag\", msg: \"closing tag \" + tagName + \" can't have attributes or invalid starting.\"}};\n                    } else {\n                        const otg = tags.pop();\n                        if (tagName !== otg) {\n                            return {err: {code: \"InvalidTag\", msg: \"closing tag \" + otg + \" is expected inplace of \" + tagName + \".\"}};\n                        }\n                    }\n                } else {\n                    const isValid = validateAttributeString(attrStr, options, regxAttrName);\n                    if (isValid !== true) {\n                        return isValid;\n                    }\n                    tags.push(tagName);\n                    tagFound = true;\n                }\n\n                //skip tag text value\n                //It may include comments and CDATA value\n                for (i++; i < xmlData.length; i++) {\n                    if (xmlData[i] === \"<\") {\n                        if (xmlData[i + 1] === \"!\") {//comment or CADATA\n                            i++;\n                            i = readCommentAndCDATA(xmlData, i);\n                            continue;\n                        } else {\n                            break;\n                        }\n                    }\n                }//end of reading tag text value\n                if (xmlData[i] === \"<\") {\n                    i--;\n                }\n            }\n        } else {\n            if (xmlData[i] === \" \" || xmlData[i] === \"\\t\" || xmlData[i] === \"\\n\" || xmlData[i] === \"\\r\") {\n                continue;\n            }\n            return {err: {code: \"InvalidChar\", msg: \"char \" + xmlData[i] + \" is not expected .\"}};\n        }\n    }\n\n    if (!tagFound) {\n        return {err: {code: \"InvalidXml\", msg: \"Start tag expected.\"}};\n    } else if (tags.length > 0) {\n        return {err: {code: \"InvalidXml\", msg: \"Invalid \" + JSON.stringify(tags, null, 4).replace(/\\r?\\n/g, \"\") + \" found.\"}};\n    }\n\n    return true;\n};\n\n/**\n * Read Processing insstructions and skip\n * @param {*} xmlData\n * @param {*} i\n */\nfunction readPI(xmlData, i) {\n    var start = i;\n    for (; i < xmlData.length; i++) {\n        if (xmlData[i] == \"?\" || xmlData[i] == \" \") {//tagname\n            var tagname = xmlData.substr(start, i - start);\n            if (i > 5 && tagname === \"xml\") {\n                return {err: {code: \"InvalidXml\", msg: \"XML declaration allowed only at the start of the document.\"}};\n            } else if (xmlData[i] == \"?\" && xmlData[i + 1] == \">\") {\n                //check if valid attribut string\n                i++;\n                break;\n            } else {\n                continue;\n            }\n        }\n    }\n    return i;\n}\n\nfunction readCommentAndCDATA(xmlData, i) {\n    if (xmlData.length > i + 5 && xmlData[i + 1] === \"-\" && xmlData[i + 2] === \"-\") {//comment\n        for (i += 3; i < xmlData.length; i++) {\n            if (xmlData[i] === \"-\" && xmlData[i + 1] === \"-\" && xmlData[i + 2] === \">\") {\n                i += 2;\n                break;\n            }\n        }\n    } else if (xmlData.length > i + 8 &&\n               xmlData[i + 1] === \"D\" &&\n               xmlData[i + 2] === \"O\" &&\n               xmlData[i + 3] === \"C\" &&\n               xmlData[i + 4] === \"T\" &&\n               xmlData[i + 5] === \"Y\" &&\n               xmlData[i + 6] === \"P\" &&\n               xmlData[i + 7] === \"E\") {\n        let angleBracketsCount = 1;\n        for (i += 8; i < xmlData.length; i++) {\n            if (xmlData[i] === \"<\") {angleBracketsCount++;}\n            else if (xmlData[i] === \">\") {\n                angleBracketsCount--;\n                if (angleBracketsCount === 0) {\n                    break;\n                }\n            }\n        }\n    } else if (xmlData.length > i + 9 &&\n               xmlData[i + 1] === \"[\" &&\n               xmlData[i + 2] === \"C\" &&\n               xmlData[i + 3] === \"D\" &&\n               xmlData[i + 4] === \"A\" &&\n               xmlData[i + 5] === \"T\" &&\n               xmlData[i + 6] === \"A\" &&\n               xmlData[i + 7] === \"[\") {\n\n        for (i += 8; i < xmlData.length; i++) {\n            if (xmlData[i] === \"]\" && xmlData[i + 1] === \"]\" && xmlData[i + 2] === \">\") {\n                i += 2;\n                break;\n            }\n        }\n    }\n\n    return i;\n}\n\nvar doubleQuote = \"\\\"\";\nvar singleQuote = \"'\";\n\n/**\n * Keep reading xmlData until '<' is found outside the attribute value.\n * @param {string} xmlData\n * @param {number} i\n */\nfunction readAttributeStr(xmlData, i) {\n    let attrStr = \"\";\n    let startChar = \"\";\n    for (; i < xmlData.length; i++) {\n        if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\n            if (startChar === \"\") {\n                startChar = xmlData[i];\n            } else if (startChar !== xmlData[i]) {\n                //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa\n                continue;\n            } else {\n                startChar = \"\";\n            }\n        } else if (xmlData[i] === \">\") {\n            if (startChar === \"\") {\n                break;\n            }\n        }\n        attrStr += xmlData[i];\n    }\n    if (startChar !== \"\") {\n        return false;\n    }\n\n    return {value: attrStr, index: i};\n}\n\n/**\n * Select all the attributes whether valid or invalid.\n */\nconst validAttrStrRegxp = new RegExp(\"(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*(['\\\"])(([\\\\s\\\\S])*?)\\\\5)?\", \"g\");\n\n//attr, =\"sd\", a=\"amit's\", a=\"sd\"b=\"saf\", ab  cd=\"\"\n\nfunction validateAttributeString(attrStr, options, regxAttrName) {\n    //console.log(\"start:\"+attrStr+\":end\");\n\n    //if(attrStr.trim().length === 0) return true; //empty string\n\n    const matches = util.getAllMatches(attrStr, validAttrStrRegxp);\n    const attrNames = [];\n\n    for (let i = 0; i < matches.length; i++) {\n        //console.log(matches[i]);\n\n        if (matches[i][1].length === 0) {//nospace before attribute name: a=\"sd\"b=\"saf\"\n            return {err: {code: \"InvalidAttr\", msg: \"attribute \" + matches[i][2] + \" has no space in starting.\"}};\n        } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {//independent attribute: ab\n            return {err: {code: \"InvalidAttr\", msg: \"boolean attribute \" + matches[i][2] + \" is not allowed.\"}};\n        }\n        /* else if(matches[i][6] === undefined){//attribute without value: ab=\n                    return { err: { code:\"InvalidAttr\",msg:\"attribute \" + matches[i][2] + \" has no value assigned.\"}};\n                } */\n        const attrName = matches[i][2];\n        if (!validateAttrName(attrName, regxAttrName)) {\n            return {err: {code: \"InvalidAttr\", msg: \"attribute \" + attrName + \" is an invalid name.\"}};\n        }\n        if (!attrNames.hasOwnProperty(attrName)) {//check for duplicate attribute.\n            attrNames[attrName] = 1;\n        } else {\n            return {err: {code: \"InvalidAttr\", msg: \"attribute \" + attrName + \" is repeated.\"}};\n        }\n    }\n\n    return true;\n\n}\n\n// const validAttrRegxp = /^[_a-zA-Z][\\w\\-.:]*$/;\n\nfunction validateAttrName(attrName, regxAttrName) {\n    // const validAttrRegxp = new RegExp(regxAttrName);\n    return util.doesMatch(attrName, regxAttrName);\n}\n\n//const startsWithXML = new RegExp(\"^[Xx][Mm][Ll]\");\n//  startsWith = /^([a-zA-Z]|_)[\\w.\\-_:]*/;\n\nfunction validateTagName(tagname, regxTagName) {\n    /*if(util.doesMatch(tagname,startsWithXML)) return false;\n    else*/\n    return !util.doesNotMatch(tagname, regxTagName);\n}\n","\"use strict\";\n//parse Empty Node as self closing node\nconst buildOptions = require(\"./util\").buildOptions;\n\nconst defaultOptions = {\n    attributeNamePrefix: \"@_\",\n    attrNodeName: false,\n    textNodeName: \"#text\",\n    ignoreAttributes: true,\n    cdataTagName: false,\n    cdataPositionChar: \"\\\\c\",\n    format: false,\n    indentBy: \"  \",\n    supressEmptyNode: false,\n    tagValueProcessor: function(a) {return a},\n    attrValueProcessor: function(a) {return a}\n};\n\nconst props = [\n    \"attributeNamePrefix\",\n    \"attrNodeName\",\n    \"textNodeName\",\n    \"ignoreAttributes\",\n    \"cdataTagName\",\n    \"cdataPositionChar\",\n    \"format\",\n    \"indentBy\",\n    \"supressEmptyNode\",\n    \"tagValueProcessor\",\n    \"attrValueProcessor\"\n]\n\nfunction Parser(options) {\n    this.options = buildOptions(options,defaultOptions,props);\n    if (this.options.ignoreAttributes || this.options.attrNodeName) {\n        this.isAttribute = function(/*a*/) { return false;};\n    } else {\n        this.attrPrefixLen = this.options.attributeNamePrefix.length;\n        this.isAttribute = isAttribute;\n    }\n    if (this.options.cdataTagName) {\n        this.isCDATA = isCDATA;\n    } else {\n        this.isCDATA = function(/*a*/) { return false;};\n    }\n    this.replaceCDATAstr = replaceCDATAstr;\n    this.replaceCDATAarr = replaceCDATAarr;\n\n    if (this.options.format) {\n        this.indentate = indentate;\n        this.tagEndChar = \">\\n\";\n        this.newLine = \"\\n\";\n    } else {\n        this.indentate = function() { return \"\";};\n        this.tagEndChar = \">\";\n        this.newLine = \"\";\n    }\n\n    if (this.options.supressEmptyNode) {\n        this.buildTextNode = buildEmptyTextNode;\n        this.buildObjNode = buildEmptyObjNode;\n    } else {\n        this.buildTextNode = buildTextValNode;\n        this.buildObjNode = buildObjectNode;\n    }\n\n    this.buildTextValNode = buildTextValNode;\n    this.buildObjectNode = buildObjectNode;\n\n}\n\nParser.prototype.parse = function(jObj) {\n    return this.j2x(jObj, 0).val;\n};\n\nParser.prototype.j2x = function(jObj, level) {\n    let attrStr = \"\";\n    let val = \"\";\n    const keys = Object.keys(jObj);\n    const len = keys.length;\n    for (let i = 0; i < len; i++) {\n        const key = keys[i];\n        if (typeof jObj[key] === \"undefined\") {\n            // supress undefined node\n        }else if (jObj[key] === null) {\n            val += this.indentate(level) + \"<\" + key + \"/\" + this.tagEndChar;\n        }else if (typeof jObj[key] !== \"object\") {//premitive type\n            const attr = this.isAttribute(key);\n            if (attr) {\n                attrStr += \" \" + attr + \"=\\\"\" +  this.options.attrValueProcessor(\"\" + jObj[key]) + \"\\\"\";\n            } else if (this.isCDATA(key)) {\n                if (jObj[this.options.textNodeName]) {\n                    val += this.replaceCDATAstr(jObj[this.options.textNodeName], jObj[key]);\n                } else {\n                    val += this.replaceCDATAstr(\"\", jObj[key]);\n                }\n            } else {//tag value\n                if (key === this.options.textNodeName) {\n                    if (jObj[this.options.cdataTagName]) {\n                        //value will added while processing cdata\n                    } else {\n                        val +=  this.options.tagValueProcessor(\"\" + jObj[key]);\n                    }\n                } else {\n                    val += this.buildTextNode(jObj[key], key, \"\", level);\n                }\n            }\n        } else if (Array.isArray(jObj[key])) {//repeated nodes\n            if (this.isCDATA(key)) {\n              val += this.indentate(level)\n                if (jObj[this.options.textNodeName]) {\n                  val += this.replaceCDATAarr(jObj[this.options.textNodeName], jObj[key]);\n                } else {\n                  val += this.replaceCDATAarr(\"\", jObj[key]);\n                }\n            } else {//nested nodes\n                const arrLen = jObj[key].length;\n                for (let j = 0; j < arrLen; j++) {\n                    const item = jObj[key][j];\n                    if (typeof item === \"undefined\") {\n                        // supress undefined node\n                    }else if(item === null){\n                        val += this.indentate(level) + \"<\" + key + \"/\" + this.tagEndChar;\n                    }else if (typeof item === \"object\") {\n                        const result = this.j2x(item, level + 1);\n                        val += this.buildObjNode(result.val, key, result.attrStr, level);\n                    } else {\n                        val += this.buildTextNode(item, key, \"\", level);\n                    }\n                }\n            }\n        } else {//nested node\n            if (this.options.attrNodeName && key === this.options.attrNodeName) {\n                const Ks = Object.keys(jObj[key]);\n                const L = Ks.length;\n                for (let j = 0; j < L; j++) {\n                    attrStr += \" \" + Ks[j] + \"=\\\"\" + this.options.tagValueProcessor(\"\" + jObj[key][Ks[j]]) + \"\\\"\";\n                }\n            } else {\n                const result = this.j2x(jObj[key], level + 1);\n                val += this.buildObjNode(result.val, key, result.attrStr, level);\n            }\n        }\n    }\n    return {attrStr: attrStr, val: val};\n};\n\nfunction replaceCDATAstr(str, cdata) {\n    str = this.options.tagValueProcessor(\"\" + str);\n    if (this.options.cdataPositionChar === \"\" || str === \"\") {\n        return str + \"<![CDATA[\" + cdata + \"]]\" + this.tagEndChar;\n    } else {\n        return str.replace(this.options.cdataPositionChar, \"<![CDATA[\" + cdata + \"]]\" + this.tagEndChar);\n    }\n}\n\nfunction replaceCDATAarr(str, cdata) {\n    str = this.options.tagValueProcessor(\"\" + str);\n    if (this.options.cdataPositionChar === \"\" || str === \"\") {\n        return str + \"<![CDATA[\" + cdata.join(\"]]><![CDATA[\") + \"]]\" + this.tagEndChar;\n    } else {\n        for (let v in cdata) {\n            str = str.replace(this.options.cdataPositionChar, \"<![CDATA[\" + cdata[v] + \"]]>\");\n        }\n        return str + this.newLine;\n    }\n}\n\nfunction buildObjectNode(val, key, attrStr, level) {\n  if (attrStr && !val.includes('<')) {\n    return this.indentate(level)\n          + \"<\" + key + attrStr\n          + \">\"\n          + val\n          //+ this.newLine\n          // + this.indentate(level)\n          + \"</\" + key + this.tagEndChar;\n  } else {\n    return this.indentate(level)\n          + \"<\" + key + attrStr\n          + this.tagEndChar\n          + val\n          //+ this.newLine\n          + this.indentate(level)\n          + \"</\" + key + this.tagEndChar;\n  }\n}\n\nfunction buildEmptyObjNode(val, key, attrStr, level) {\n    if (val !== \"\") {\n        return this.buildObjectNode(val, key, attrStr, level);\n    } else {\n        return this.indentate(level)\n               + \"<\" + key + attrStr\n               + \"/\"\n               + this.tagEndChar;\n        //+ this.newLine\n    }\n}\n\nfunction buildTextValNode(val, key, attrStr, level) {\n    return this.indentate(level) + \"<\" + key + attrStr + \">\" + this.options.tagValueProcessor(\"\" + val) + \"</\" + key + this.tagEndChar;\n}\n\nfunction buildEmptyTextNode(val, key, attrStr, level) {\n    if (val !== \"\") {\n        return this.buildTextValNode(val, key, attrStr, level);\n    } else {\n        return this.indentate(level) + \"<\" + key + attrStr + \"/\" + this.tagEndChar;\n    }\n}\n\nfunction indentate(level) {\n    return this.options.indentBy.repeat(level);\n}\n\nfunction isAttribute(name/*, options*/) {\n    if (name.startsWith(this.options.attributeNamePrefix)) {\n        return name.substr(this.attrPrefixLen);\n    } else {\n        return false;\n    }\n}\n\nfunction isCDATA(name) {\n    return name === this.options.cdataTagName;\n}\n\n//formatting\n//indentation\n//\\n after each closing or self closing tag\n\nmodule.exports = Parser;\n"],"sourceRoot":""}