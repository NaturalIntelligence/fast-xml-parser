{"version":3,"sources":["webpack://parser/webpack/bootstrap","webpack://parser/./src/util.js","webpack://parser/./src/x2j.js","webpack://parser/./src/n2j-str.js","webpack://parser/./src/n2j.js","webpack://parser/./src/j2x.js","webpack://parser/./src/validator.js","webpack://parser/./src/nimn-data.js","webpack://parser/./src/xml-node.js","webpack://parser/./src/parser.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","isExist","v","doesMatch","string","regex","match","exec","buildOptions","options","defaultOptions","props","newOptions","length","undefined","getValue","merge","target","source","_arr","keys","_i","key","isEmptyObject","obj","doesNotMatch","getAllMatches","matches","push","_toConsumableArray","XmlNode","TagType","OPENING","CLOSING","SELF","CDATA","attributeNamePrefix","attrNodeName","textNodeName","ignoreAttributes","ignoreNameSpace","allowBooleanAttributes","parseNodeValue","parseAttributeValue","arrayMode","trimValues","cdataTagName","cdataPositionChar","tagValueProcessor","a","attrValueProcessor","processTagValue","val","trim","parseValue","resolveNameSpace","tagname","tags","split","prefix","charAt","shouldParse","isNaN","indexOf","parseFloat","parseInt","attrsRegx","RegExp","buildAttributesMap","attrStr","replace","attrs","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","next","done","attrName","err","return","attrCollection","getTraversalObj","xmlData","xmlObj","currentNode","tagsRegx","tag","nextTag","tagType","substr","parent","childNode","attrsMap","addChild","_cToJsonStr","node","level","jObj","child","_arr2","_i2","convertToJsonString","indentBy","convertToJson","format","supressEmptyNode","Parser","_classCallCheck","this","isAttribute","attrPrefixLen","isCDATA","replaceCDATAstr","replaceCDATAarr","indentate","tagEndChar","newLine","buildTextNode","buildEmptyTextNode","buildObjNode","buildEmptyObjNode","buildTextValNode","buildObjectNode","j2x","_typeof","attr","Array","isArray","item","result","attrKey","str","cdata","join","_arr3","_i3","repeat","startsWith","readPI","start","tagName","code","msg","readCommentAndCDATA","angleBracketsCount","doubleQuote","singleQuote","readAttributeStr","startChar","index","validAttrStrRegxp","validateAttributeString","attrNames","validateAttrName","validAttrRegxp","validate","tagFound","closingTag","substring","isValid","otg","pop","JSON","stringify","char","String","fromCharCode","chars","nilChar","missingChar","nilPremitive","missingPremitive","emptyChar","emptyValue","boundryChar","arrayEnd","objStart","arrStart","charsArr","processValue","isAppChar","ch","hasData","convertToNimn","e_schema","_e","hasValidData","itemSchema","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","j2xParser","parse","parseToNimn","schema"],"mappings":"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","file":"./parser.browser.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n","const getAllMatches = (string, regex) => {\n    const matches = [];\n    let match;\n    while ((match = regex.exec(string)) !== null) {\n        matches.push([...match]);\n    }\n    return matches;\n};\n\n/**\n * Copy all the properties of a into b.\n * @param {*} target\n * @param {*} source\n */\nconst merge = (target, source) => {\n    if (source) {\n        for (let key of Object.keys(source)) {\n            target[key] = source[key];\n        }\n    }\n    return target;\n};\n\nconst isEmptyObject = (obj) => Object.keys(obj).length === 0;\nconst isExist = (v) => typeof v !== \"undefined\";\n\nconst doesMatch = (string, regex) => {\n    const match = regex.exec(string);\n    return !(match === null || !isExist(match));\n};\n\nconst doesNotMatch = (string, regex) => !doesMatch(string, regex);\n\nconst getValue = (v) => isExist(v) ? v : \"\";\n\n// const fakeCall = function(a) {return a;};\n// const fakeCallNoReturn = function() {};\nconst buildOptions = function(options,defaultOptions,props) {\n    var newOptions = {};\n    if (!options) {\n        options = {};\n    }\n\n    for (let i = 0; i < props.length; i++) {\n        if ( options[props[i]] !== undefined) {\n            newOptions[props[i]] = options[props[i]];\n        }else{\n            newOptions[props[i]] = defaultOptions[props[i]];\n        }\n    }\n    return newOptions;\n};\n\nmodule.exports = {\n    buildOptions,\n    getValue,\n    merge,\n    isEmptyObject,\n    isExist,\n    doesMatch,\n    doesNotMatch,\n    getAllMatches\n};\n","const {buildOptions, getValue, isExist, getAllMatches} = require(\"./util\");\nconst {XmlNode} = require(\"./xml-node\");\nconst TagType = {\"OPENING\": 1, \"CLOSING\": 2, \"SELF\": 3, \"CDATA\": 4};\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\n//treat cdata as a tag\n\nconst defaultOptions = {\n    attributeNamePrefix: \"@_\",\n    attrNodeName: false,\n    textNodeName: \"#text\",\n    ignoreAttributes: true,\n    ignoreNameSpace: false,\n    allowBooleanAttributes: false,         //a tag can have attributes without any value\n    //ignoreRootElement : false,\n    parseNodeValue: true,\n    parseAttributeValue: false,\n    arrayMode: false,\n    trimValues: true,                                //Trim string values of tag and attributes\n    cdataTagName: false,\n    cdataPositionChar: \"\\\\c\",\n    tagValueProcessor: (a) => a,\n    attrValueProcessor: (a) => a\n    //decodeStrict: false,\n};\n\nexports.defaultOptions = defaultOptions;\nconst props = [\"attributeNamePrefix\", \"attrNodeName\", \"textNodeName\", \"ignoreAttributes\", \"ignoreNameSpace\", \"allowBooleanAttributes\", \"parseNodeValue\", \"parseAttributeValue\", \"arrayMode\", \"trimValues\", \"cdataTagName\", \"cdataPositionChar\", \"tagValueProcessor\", \"attrValueProcessor\"];\n\nconst getTraversalObj = function(xmlData, options) {\n    //options = buildOptions(options);\n    options = buildOptions(options,defaultOptions,props);\n    //xmlData = xmlData.replace(/\\r?\\n/g, \" \");//make it single line\n    xmlData = xmlData.replace(/<!--[\\s\\S]*?-->/g, \"\");//Remove  comments\n\n    const xmlObj = new XmlNode(\"!xml\");\n    let currentNode = xmlObj;\n\n    const tagsRegx = /<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|(([\\w:\\-._]*:)?([\\w:\\-._]+))([^>]*)>|((\\/)(([\\w:\\-._]*:)?([\\w:\\-._]+))>))([^<]*)/g;\n    let tag = tagsRegx.exec(xmlData);\n    let nextTag = tagsRegx.exec(xmlData);\n    while (tag) {\n        const tagType = checkForTagType(tag);\n\n        if (tagType === TagType.CLOSING) {\n            //add parsed data to parent node\n            if (currentNode.parent && tag[14]) {\n                currentNode.parent.val = getValue(currentNode.parent.val) + \"\" + processTagValue(tag[14], options);\n            }\n\n            currentNode = currentNode.parent;\n        } else if (tagType === TagType.CDATA) {\n            if (options.cdataTagName) {\n                //add cdata node\n                const childNode = new XmlNode(options.cdataTagName, currentNode, tag[3]);\n                childNode.attrsMap = buildAttributesMap(tag[8], options);\n                currentNode.addChild(childNode);\n                //for backtracking\n                currentNode.val = getValue(currentNode.val) + options.cdataPositionChar;\n                //add rest value to parent node\n                if (tag[14]) {\n                    currentNode.val += processTagValue(tag[14], options);\n                }\n            } else {\n                currentNode.val = (currentNode.val || \"\") + (tag[3] || \"\") + processTagValue(tag[14], options);\n            }\n        } else if (tagType === TagType.SELF) {\n            const childNode = new XmlNode(options.ignoreNameSpace ? tag[7] : tag[5], currentNode, \"\");\n            if (tag[8] && tag[8].length > 1) {\n                tag[8] = tag[8].substr(0, tag[8].length - 1);\n            }\n            childNode.attrsMap = buildAttributesMap(tag[8], options);\n            currentNode.addChild(childNode);\n        } else {//TagType.OPENING\n            const childNode = new XmlNode(options.ignoreNameSpace ? tag[7] : tag[5], currentNode, processTagValue(tag[14], options));\n            childNode.attrsMap = buildAttributesMap(tag[8], options);\n            currentNode.addChild(childNode);\n            currentNode = childNode;\n        }\n\n        tag = nextTag;\n        nextTag = tagsRegx.exec(xmlData);\n    }\n\n    return xmlObj;\n};\n\nfunction processTagValue(val, options) {\n    if (val) {\n        if (options.trimValues) {\n            val = val.trim();\n        }\n        val = options.tagValueProcessor(val);\n        val = parseValue(val, options.parseNodeValue);\n    }\n\n    return val;\n}\n\nfunction checkForTagType(match) {\n    if (match[4] === \"]]>\") {\n        return TagType.CDATA;\n    } else if (match[10] === \"/\") {\n        return TagType.CLOSING;\n    } else if (typeof match[8] !== \"undefined\" && match[8].substr(match[8].length - 1) === \"/\") {\n        return TagType.SELF;\n    } else {\n        return TagType.OPENING;\n    }\n}\n\nfunction resolveNameSpace(tagname, options) {\n    if (options.ignoreNameSpace) {\n        const tags = tagname.split(\":\");\n        const prefix = tagname.charAt(0) === \"/\" ? \"/\" : \"\";\n        if (tags[0] === \"xmlns\") {\n            return \"\";\n        }\n        if (tags.length === 2) {\n            tagname = prefix + tags[1];\n        }\n    }\n    return tagname;\n}\n\nfunction parseValue(val, shouldParse) {\n    if (shouldParse && typeof val === \"string\") {\n        if (val.trim() === \"\" || isNaN(val)) {\n            val = val === \"true\" ? true : val === \"false\" ? false : val;\n        } else {\n            if (val.indexOf(\".\") !== -1) {\n                val = parseFloat(val);\n            } else {\n                val = parseInt(val, 10);\n            }\n        }\n        return val;\n    }\n    if (isExist(val)) {\n        return val;\n    }\n    return \"\";\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp(\"([^\\\\s=]+)\\\\s*(=\\\\s*(['\\\"])(.*?)\\\\3)?\", \"g\");\n\nfunction buildAttributesMap(attrStr, options) {\n    if (!options.ignoreAttributes && typeof attrStr === \"string\") {\n        attrStr = attrStr.replace(/\\r?\\n/g, \" \");\n        //attrStr = attrStr || attrStr.trim();\n\n        const matches = getAllMatches(attrStr, attrsRegx);\n        const attrs = {};\n        for (let match of matches) {\n            const attrName = resolveNameSpace(match[1], options);\n            if (attrName.length) {\n                if (match[4] !== undefined) {\n                    if (options.trimValues) {\n                        match[4] = match[4].trim();\n                    }\n                    match[4] = options.attrValueProcessor(match[4]);\n                    attrs[options.attributeNamePrefix + attrName] = parseValue(match[4], options.parseAttributeValue);\n                } else if (options.allowBooleanAttributes) {\n                    attrs[options.attributeNamePrefix + attrName] = true;\n                }\n\n            }\n        }\n        if (!Object.keys(attrs).length) {\n            return;\n        }\n        if (options.attrNodeName) {\n            const attrCollection = {};\n            attrCollection[options.attrNodeName] = attrs;\n            return attrCollection;\n        }\n        return attrs;\n    }\n}\n\nmodule.exports = {\n    props,\n    defaultOptions,\n    getTraversalObj\n};\n","\"use strict\";\n\nconst {buildOptions, isEmptyObject, isExist, merge} = require(\"./util\");\nconst {defaultOptions, props} = require(\"./x2j\");\n\n//TODO: do it later\nconst convertToJsonString = function(node, options) {\n    options = buildOptions(options,defaultOptions,props);\n\n    options.indentBy = options.indentBy || \"\";\n    return _cToJsonStr(node, options, 0);\n};\n\nconst _cToJsonStr = function(node, options, level) {\n    let jObj = \"{\";\n\n    //traver through all the children\n    for (let tagname of Object.keys(node.child)) {\n        if (node.child[tagname] && node.child[tagname].length > 1) {\n            jObj += \"\\\"\" + tagname + \"\\\" : [ \";\n            for (let tag of Object.keys(node.child[tagname])) {\n                jObj += _cToJsonStr(node.child[tagname][tag], options) + \" , \";\n            }\n            jObj = jObj.substr(0, jObj.length - 1) + \" ] \"; //remove extra comma in last\n        } else {\n            jObj += \"\\\"\" + tagname + \"\\\" : \" + _cToJsonStr(node.child[tagname][0], options) + \" ,\";\n        }\n    }\n    merge(jObj, node.attrsMap);\n    //add attrsMap as new children\n    if (isEmptyObject(jObj)) {\n        return isExist(node.val) ? node.val : \"\";\n    } else {\n        if (isExist(node.val)) {\n            if (!(typeof node.val === \"string\" && (node.val === \"\" || node.val === options.cdataPositionChar))) {\n                jObj += \"\\\"\" + options.textNodeName + \"\\\" : \" + stringval(node.val);\n            }\n        }\n    }\n    //add value\n    if (jObj[jObj.length - 1] === \",\") {\n        jObj = jObj.substr(0, jObj.length - 2);\n    }\n    return jObj + \"}\";\n};\n\nfunction stringval(v) {\n    if (v === true || v === false || !isNaN(v)) {\n        return v;\n    } else {\n        return \"\\\"\" + v + \"\\\"\";\n    }\n}\n\nfunction indentate(options, level) {\n    return options.indentBy.repeat(level);\n}\n\nmodule.exports = {convertToJsonString};\n","const {isEmptyObject, merge, isExist} = require(\"./util\");\n\nconst convertToJson = function(node, options) {\n    const jObj = {};\n\n    if ((!node.child || isEmptyObject(node.child)) && (!node.attrsMap || isEmptyObject(node.attrsMap))) {\n        return isExist(node.val) ? node.val : \"\";\n    } else {\n        if (isExist(node.val)) {\n            if (!(typeof node.val === \"string\" && (node.val === \"\" || node.val === options.cdataPositionChar))) {\n                jObj[options.textNodeName] = node.val;\n            }\n        }\n    }\n\n    merge(jObj, node.attrsMap);\n\n    for (let tagname of  Object.keys(node.child)) {\n        if (node.child[tagname] && node.child[tagname].length > 1) {\n            jObj[tagname] = [];\n            for (let tag of Object.keys(node.child[tagname])) {\n                jObj[tagname].push(convertToJson(node.child[tagname][tag], options));\n            }\n        } else {\n            jObj[tagname] = convertToJson(node.child[tagname][0], options);\n        }\n    }\n\n    //add value\n    return jObj;\n};\n\nmodule.exports = {convertToJson};\n","const {isExist, buildOptions} = require(\"./util\");\n\nconst defaultOptions = {\n    attributeNamePrefix: \"@_\",\n    attrNodeName: false,\n    textNodeName: \"#text\",\n    ignoreAttributes: true,\n    cdataTagName: false,\n    cdataPositionChar: \"\\\\c\",\n    format: false,\n    indentBy: \"  \",\n    supressEmptyNode: false,\n    tagValueProcessor: (a) => a,\n    attrValueProcessor: (a) => a\n};\n\nconst props = [\n    \"attributeNamePrefix\",\n    \"attrNodeName\",\n    \"textNodeName\",\n    \"ignoreAttributes\",\n    \"cdataTagName\",\n    \"cdataPositionChar\",\n    \"format\",\n    \"indentBy\",\n    \"supressEmptyNode\",\n    \"tagValueProcessor\",\n    \"attrValueProcessor\"\n];\n\nclass Parser {\n    constructor(options) {\n        this.options = buildOptions(options, defaultOptions, props);\n        if (this.options.ignoreAttributes || this.options.attrNodeName) {\n            this.isAttribute = function(/*a*/) { return false;};\n        } else {\n            this.attrPrefixLen = this.options.attributeNamePrefix.length;\n            this.isAttribute = isAttribute;\n        }\n        if (this.options.cdataTagName) {\n            this.isCDATA = isCDATA;\n        } else {\n            this.isCDATA = (/*a*/) => false;\n        }\n        this.replaceCDATAstr = replaceCDATAstr;\n        this.replaceCDATAarr = replaceCDATAarr;\n\n        if (this.options.format) {\n            this.indentate = indentate;\n            this.tagEndChar = \">\\n\";\n            this.newLine = \"\\n\";\n        } else {\n            this.indentate = () => \"\";\n            this.tagEndChar = \">\";\n            this.newLine = \"\";\n        }\n\n        if (this.options.supressEmptyNode) {\n            this.buildTextNode = buildEmptyTextNode;\n            this.buildObjNode = buildEmptyObjNode;\n        } else {\n            this.buildTextNode = buildTextValNode;\n            this.buildObjNode = buildObjectNode;\n        }\n\n        this.buildTextValNode = buildTextValNode;\n        this.buildObjectNode = buildObjectNode;\n    }\n\n    parse(jObj) {\n        return this.j2x(jObj, 0).val;\n    }\n\n    j2x(jObj, level) {\n        let attrStr = \"\";\n        let val = \"\";\n        for (let key of Object.keys(jObj)) {\n            if (!isExist(jObj[key])) {\n                // supress undefined node\n            }\n            else if (typeof jObj[key] !== \"object\") {//premitive type\n                const attr = this.isAttribute(key);\n                if (attr) {\n                    attrStr += \" \" + attr + \"=\\\"\" + this.options.attrValueProcessor(\"\" + jObj[key]) + \"\\\"\";\n                } else if (this.isCDATA(key)) {\n                    if (jObj[this.options.textNodeName]) {\n                        val += this.replaceCDATAstr(jObj[this.options.textNodeName], jObj[key]);\n                    } else {\n                        val += this.replaceCDATAstr(\"\", jObj[key]);\n                    }\n                } else {//tag value\n                    if (key === this.options.textNodeName) {\n                        if (jObj[this.options.cdataTagName]) {\n                            //value will added while processing cdata\n                        } else {\n                            val += this.options.tagValueProcessor(\"\" + jObj[key]);\n                        }\n                    } else {\n                        val += this.buildTextNode(jObj[key], key, \"\", level);\n                    }\n                }\n            } else if (Array.isArray(jObj[key])) {//repeated nodes\n                if (this.isCDATA(key)) {\n                    if (jObj[this.options.textNodeName]) {\n                        val += this.replaceCDATAarr(jObj[this.options.textNodeName], jObj[key]);\n                    } else {\n                        val += this.replaceCDATAarr(\"\", jObj[key]);\n                    }\n                } else {//nested nodes\n                    for (let item of jObj[key]) {\n                        if (!isExist(item)) {\n                            // supress undefined node\n                        }\n                        else if (typeof item === \"object\") {\n                            const result = this.j2x(item, level + 1);\n                            val += this.buildObjNode(result.val, key, result.attrStr, level);\n                        } else {\n                            val += this.buildTextNode(item, key, \"\", level);\n                        }\n                    }\n                }\n            } else {\n                if (this.options.attrNodeName && key === this.options.attrNodeName) {\n                    for (let attrKey of Object.keys(jObj[key])) {\n                        attrStr += \" \" + attrKey + \"=\\\"\" + this.options.tagValueProcessor(\"\" + jObj[key][attrKey]) + \"\\\"\";\n                    }\n                } else {\n                    const result = this.j2x(jObj[key], level + 1);\n                    val += this.buildObjNode(result.val, key, result.attrStr, level);\n                }\n            }\n        }\n        return {attrStr: attrStr, val: val};\n    }\n}\n\nfunction replaceCDATAstr(str, cdata) {\n    str = this.options.tagValueProcessor(\"\" + str);\n    if (this.options.cdataPositionChar === \"\" || str === \"\") {\n        return str + \"<![CDATA[\" + cdata + \"]]>\";\n    } else {\n        return str.replace(this.options.cdataPositionChar, \"<![CDATA[\" + cdata + \"]]>\");\n    }\n}\n\nfunction replaceCDATAarr(str, cdata) {\n    str = this.options.tagValueProcessor(\"\" + str);\n    if (this.options.cdataPositionChar === \"\" || str === \"\") {\n        return str + \"<![CDATA[\" + cdata.join(\"]]><![CDATA[\") + \"]]>\";\n    } else {\n        for (const v of Object.keys(cdata)) {\n            str = str.replace(this.options.cdataPositionChar, \"<![CDATA[\" + cdata[v] + \"]]>\");\n        }\n        return str;\n    }\n}\n\nfunction buildObjectNode(val, key, attrStr, level) {\n    return this.indentate(level)\n           + \"<\" + key + attrStr\n           + this.tagEndChar\n           + val\n           //+ this.newLine\n           + this.indentate(level)\n           + \"</\" + key + this.tagEndChar;\n}\n\nfunction buildEmptyObjNode(val, key, attrStr, level) {\n    if (val !== \"\") {\n        return this.buildObjectNode(val, key, attrStr, level);\n    } else {\n        return this.indentate(level)\n               + \"<\" + key + attrStr\n               + \"/\"\n               + this.tagEndChar;\n        //+ this.newLine\n    }\n}\n\nfunction buildTextValNode(val, key, attrStr, level) {\n    return this.indentate(level) + \"<\" + key + attrStr + \">\" + this.options.tagValueProcessor(\"\" + val) + \"</\" + key + this.tagEndChar;\n}\n\nfunction buildEmptyTextNode(val, key, attrStr, level) {\n    if (val !== \"\") {\n        return this.buildTextValNode(val, key, attrStr, level);\n    } else {\n        return this.indentate(level) + \"<\" + key + attrStr + \"/\" + this.tagEndChar;\n    }\n}\n\nfunction indentate(level) {\n    return this.options.indentBy.repeat(level);\n}\n\nfunction isAttribute(name/*, options*/) {\n    if (name.startsWith(this.options.attributeNamePrefix)) {\n        return name.substr(this.attrPrefixLen);\n    } else {\n        return false;\n    }\n}\n\nfunction isCDATA(name) {\n    return name === this.options.cdataTagName;\n}\n\n//formatting\n//indentation\n//\\n after each closing or self closing tag\n\nmodule.exports = {Parser, isAttribute};\n","const {buildOptions, getAllMatches, doesMatch, doesNotMatch} = require(\"./util\");\n\nconst defaultOptions = {\n    allowBooleanAttributes: false         //A tag can have attributes without any value\n};\n\nconst props = [\"allowBooleanAttributes\"];\n\n//const tagsPattern = new RegExp(\"<\\\\/?([\\\\w:\\\\-_\\.]+)\\\\s*\\/?>\",\"g\");\nconst validate = function(xmlData, options) {\n    options = buildOptions(options, defaultOptions, props);\n\n    //xmlData = xmlData.replace(/(\\r\\n|\\n|\\r)/gm,\"\");//make it single line\n    //xmlData = xmlData.replace(/(^\\s*<\\?xml.*?\\?>)/g,\"\");//Remove XML starting tag\n    //xmlData = xmlData.replace(/(<!DOCTYPE[\\s\\w\\\"\\.\\/\\-\\:]+(\\[.*\\])*\\s*>)/g,\"\");//Remove DOCTYPE\n\n    const tags = [];\n    let tagFound = false;\n    for (let i = 0; i < xmlData.length; i++) {\n\n        if (xmlData[i] === \"<\") {//starting of tag\n            //read until you reach to '>' avoiding any '>' in attribute value\n            i++;\n            if (xmlData[i] === \"?\") {\n                i = readPI(xmlData, ++i);\n                if (i.err) {\n                    return i;\n                }\n            } else if (xmlData[i] === \"!\") {\n                i = readCommentAndCDATA(xmlData, i);\n                continue;\n            } else {\n                let closingTag = false;\n                if (xmlData[i] === \"/\") {//closing tag\n                    closingTag = true;\n                    i++;\n                }\n                //read tagname\n                let tagName = \"\";\n                for (; i < xmlData.length &&\n                       xmlData[i] !== \">\" &&\n                       xmlData[i] !== \" \" &&\n                       xmlData[i] !== \"\\t\"; i++) {\n\n                    tagName += xmlData[i];\n                }\n                tagName = tagName.trim();\n                //console.log(tagName);\n\n                if (tagName[tagName.length - 1] === \"/\") {//self closing tag without attributes\n                    tagName = tagName.substring(0, tagName.length - 1);\n                    continue;\n                }\n                if (!validateTagName(tagName)) {\n                    return {err: {code: \"InvalidTag\", msg: \"Tag \" + tagName + \" is an invalid name.\"}};\n                }\n\n                const result = readAttributeStr(xmlData, i);\n                if (result === false) {\n                    return {err: {code: \"InvalidAttr\", msg: \"Attributes for \" + tagName + \" have open quote\"}};\n                }\n                let attrStr = result.value;\n                i = result.index;\n\n                if (attrStr[attrStr.length - 1] === \"/\") {//self closing tag\n                    attrStr = attrStr.substring(0, attrStr.length - 1);\n                    const isValid = validateAttributeString(attrStr, options);\n                    if (isValid === true) {\n                        tagFound = true;\n                        continue;\n                    } else {\n                        return isValid;\n                    }\n                } else if (closingTag) {\n                    if (attrStr.trim().length > 0) {\n                        return {err: {code: \"InvalidTag\", msg: \"closing tag \" + tagName + \" can't have attributes or invalid starting.\"}};\n                    } else {\n                        const otg = tags.pop();\n                        if (tagName !== otg) {\n                            return {err: {code: \"InvalidTag\", msg: \"closing tag \" + otg + \" is expected inplace of \" + tagName + \".\"}};\n                        }\n                    }\n                } else {\n                    const isValid = validateAttributeString(attrStr, options);\n                    if (isValid !== true) {\n                        return isValid;\n                    }\n                    tags.push(tagName);\n                    tagFound = true;\n                }\n\n                //skip tag text value\n                //It may include comments and CDATA value\n                for (i++; i < xmlData.length; i++) {\n                    if (xmlData[i] === \"<\") {\n                        if (xmlData[i + 1] === \"!\") {//comment or CADATA\n                            i++;\n                            i = readCommentAndCDATA(xmlData, i);\n                            continue;\n                        } else {\n                            break;\n                        }\n                    }\n                }//end of reading tag text value\n                if (xmlData[i] === \"<\") {\n                    i--;\n                }\n            }\n        } else {\n            if (xmlData[i] === \" \" || xmlData[i] === \"\\t\" || xmlData[i] === \"\\n\" || xmlData[i] === \"\\r\") {\n                continue;\n            }\n            return {err: {code: \"InvalidChar\", msg: \"char \" + xmlData[i] + \" is not expected .\"}};\n        }\n    }\n\n    if (!tagFound) {\n        return {err: {code: \"InvalidXml\", msg: \"Start tag expected.\"}};\n    } else if (tags.length > 0) {\n        return {err: {code: \"InvalidXml\", msg: \"Invalid \" + JSON.stringify(tags, null, 4).replace(/\\r?\\n/g, \"\") + \" found.\"}};\n    }\n\n    return true;\n};\n\n/**\n * Read Processing insstructions and skip\n * @param {*} xmlData\n * @param {*} i\n */\nfunction readPI(xmlData, i) {\n    const start = i;\n    for (; i < xmlData.length; i++) {\n        if (xmlData[i] === \"?\" || xmlData[i] === \" \") { //tagName\n            const tagName = xmlData.substr(start, i - start);\n            if (i > 5 && tagName === \"xml\") {\n                return {err: {code: \"InvalidXml\", msg: \"XML declaration allowed only at the start of the document.\"}};\n            } else if (xmlData[i] === \"?\" && xmlData[i + 1] === \">\") {\n                //check if valid attribute string\n                i++;\n                break;\n            } else {\n                continue;\n            }\n        }\n    }\n    return i;\n}\n\nfunction readCommentAndCDATA(xmlData, i) {\n    if (xmlData.length > i + 5 && xmlData[i + 1] === \"-\" && xmlData[i + 2] === \"-\") {//comment\n        for (i += 3; i < xmlData.length; i++) {\n            if (xmlData[i] === \"-\" && xmlData[i + 1] === \"-\" && xmlData[i + 2] === \">\") {\n                i += 2;\n                break;\n            }\n        }\n    } else if (xmlData.length > i + 8 &&\n               xmlData[i + 1] === \"D\" &&\n               xmlData[i + 2] === \"O\" &&\n               xmlData[i + 3] === \"C\" &&\n               xmlData[i + 4] === \"T\" &&\n               xmlData[i + 5] === \"Y\" &&\n               xmlData[i + 6] === \"P\" &&\n               xmlData[i + 7] === \"E\") {\n        let angleBracketsCount = 1;\n        for (i += 8; i < xmlData.length; i++) {\n            if (xmlData[i] === \"<\") {angleBracketsCount++;}\n            else if (xmlData[i] === \">\") {\n                angleBracketsCount--;\n                if (angleBracketsCount === 0) {\n                    break;\n                }\n            }\n        }\n    } else if (xmlData.length > i + 9 &&\n               xmlData[i + 1] === \"[\" &&\n               xmlData[i + 2] === \"C\" &&\n               xmlData[i + 3] === \"D\" &&\n               xmlData[i + 4] === \"A\" &&\n               xmlData[i + 5] === \"T\" &&\n               xmlData[i + 6] === \"A\" &&\n               xmlData[i + 7] === \"[\") {\n\n        for (i += 8; i < xmlData.length; i++) {\n            if (xmlData[i] === \"]\" && xmlData[i + 1] === \"]\" && xmlData[i + 2] === \">\") {\n                i += 2;\n                break;\n            }\n        }\n    }\n\n    return i;\n}\n\nconst doubleQuote = \"\\\"\";\nconst singleQuote = \"'\";\n\n/**\n * Keep reading xmlData until '<' is found outside the attribute value.\n * @param {string} xmlData\n * @param {number} i\n */\nfunction readAttributeStr(xmlData, i) {\n    let attrStr = \"\";\n    let startChar = \"\";\n    for (; i < xmlData.length; i++) {\n        if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\n            if (startChar === \"\") {\n                startChar = xmlData[i];\n            } else if (startChar !== xmlData[i]) {\n                //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa\n                continue;\n            } else {\n                startChar = \"\";\n            }\n        } else if (xmlData[i] === \">\") {\n            if (startChar === \"\") {\n                break;\n            }\n        }\n        attrStr += xmlData[i];\n    }\n    if (startChar !== \"\") {\n        return false;\n    }\n\n    return {value: attrStr, index: i};\n}\n\n/**\n * Select all the attributes whether valid or invalid.\n */\nconst validAttrStrRegxp = new RegExp(\"(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*(['\\\"])(([\\\\s\\\\S])*?)\\\\5)?\", \"g\");\n\n//attr, =\"sd\", a=\"amit's\", a=\"sd\"b=\"saf\", ab  cd=\"\"\n\nfunction validateAttributeString(attrStr, options) {\n    //console.log(\"start:\"+attrStr+\":end\");\n\n    //if(attrStr.trim().length === 0) return true; //empty string\n\n    const matches = getAllMatches(attrStr, validAttrStrRegxp);\n    const attrNames = [];\n\n    for (let match of matches) {\n        //console.log(matches[i]);\n\n        if (match[1].length === 0) {//nospace before attribute name: a=\"sd\"b=\"saf\"\n            return {err: {code: \"InvalidAttr\", msg: \"attribute \" + match[2] + \" has no space in starting.\"}};\n        } else if (match[3] === undefined && !options.allowBooleanAttributes) {//independent attribute: ab\n            return {err: {code: \"InvalidAttr\", msg: \"boolean attribute \" + match[2] + \" is not allowed.\"}};\n        }\n        /* else if(matches[i][6] === undefined){//attribute without value: ab=\n                    return { err: { code:\"InvalidAttr\",msg:\"attribute \" + matches[i][2] + \" has no value assigned.\"}};\n                } */\n        const attrName = match[2];\n        if (!validateAttrName(attrName)) {\n            return {err: {code: \"InvalidAttr\", msg: \"attribute \" + attrName + \" is an invalid name.\"}};\n        }\n        if (!attrNames.hasOwnProperty(attrName)) {//check for duplicate attribute.\n            attrNames[attrName] = 1;\n        } else {\n            return {err: {code: \"InvalidAttr\", msg: \"attribute \" + attrName + \" is repeated.\"}};\n        }\n    }\n\n    return true;\n\n}\n\nconst validAttrRegxp = /^[_a-zA-Z][\\w\\-.:]*$/;\n\nfunction validateAttrName(attrName) {\n    return doesMatch(attrName, validAttrRegxp);\n}\n\n//const startsWithXML = new RegExp(\"^[Xx][Mm][Ll]\");\nconst startsWith = /^([a-zA-Z]|_)[\\w.\\-_:]*/;\n\nfunction validateTagName(tagname) {\n    /*if(doesMatch(tagname,startsWithXML)) return false;\n    else*/\n    return !doesNotMatch(tagname, startsWith);\n}\n\nmodule.exports = {validate};\n","const char = (a) => String.fromCharCode(a);\n\nconst chars = {\n    nilChar: char(254),\n    missingChar: char(200),\n    nilPremitive: char(176),\n    missingPremitive: char(201),\n    emptyChar: char(177),\n    emptyValue: char(178),\n    boundryChar: char(186),\n    arrayEnd: char(197),\n    objStart: char(198),\n    arrStart: char(199)\n};\n\nconst charsArr = [\n    chars.nilChar,\n    chars.nilPremitive,\n    chars.missingChar,\n    chars.missingPremitive,\n    chars.boundryChar,\n    chars.emptyChar,\n    chars.arrayEnd,\n    chars.objStart,\n    chars.arrStart\n];\n\nconst _e = (node, e_schema, options) => {\n    if (typeof e_schema === \"string\") {//premitive\n        if (node && node[0] && node[0].val !== undefined) {\n            return getValue(node[0].val, e_schema);\n        } else {\n            return getValue(node, e_schema);\n        }\n    } else {\n        const hasValidData = hasData(node);\n        if (hasValidData === true) {\n            let str = \"\";\n            if (Array.isArray(e_schema)) {\n                //attributes can't be repeated. hence check in children tags only\n                str += chars.arrStart;\n                const itemSchema = e_schema[0];\n                //var itemSchemaType = itemSchema;\n                if (typeof itemSchema === \"string\") {\n                    for (let item of node) {\n                        const r = getValue(item.val, itemSchema);\n                        str = processValue(str, r);\n                    }\n                } else {\n                    for (let item of node) {\n                        const r = _e(item, itemSchema, options);\n                        str = processValue(str, r);\n                    }\n                }\n                str += chars.arrayEnd;//indicates that next item is not array item\n            } else {//object\n                str += chars.objStart;\n                if (Array.isArray(node)) {\n                    node = node[0];\n                }\n                for (let key of Object.keys(e_schema)) {\n                    //a property defined in schema can be present either in attrsMap or children tags\n                    //options.textNodeName will not present in both maps, take it's value from val\n                    //options.attrNodeName will be present in attrsMap\n                    let r;\n                    if (!options.ignoreAttributes && node.attrsMap && node.attrsMap[key]) {\n                        r = _e(node.attrsMap[key], e_schema[key], options);\n                    } else if (key === options.textNodeName) {\n                        r = _e(node.val, e_schema[key], options);\n                    } else {\n                        r = _e(node.child[key], e_schema[key], options);\n                    }\n                    str = processValue(str, r);\n                }\n            }\n            return str;\n        } else {\n            return hasValidData;\n        }\n    }\n};\n\nconst getValue = (a/*, type*/) => {\n    switch (a) {\n        case undefined:\n            return chars.missingPremitive;\n        case null:\n            return chars.nilPremitive;\n        case \"\":\n            return chars.emptyValue;\n        default:\n            return a;\n    }\n};\n\nconst processValue = (str, r) => {\n    if (!isAppChar(r[0]) && !isAppChar(str[str.length - 1])) {\n        str += chars.boundryChar;\n    }\n    return str + r;\n};\n\nconst isAppChar = (ch) => {\n    return charsArr.indexOf(ch) !== -1;\n};\n\nconst hasData = (jObj) => {\n    if (jObj === undefined) {\n        return chars.missingChar;\n    } else if (jObj === null) {\n        return chars.nilChar;\n    } else if (jObj.child && Object.keys(jObj.child).length === 0 && (!jObj.attrsMap || Object.keys(jObj.attrsMap).length === 0)) {\n        return chars.emptyChar;\n    } else {\n        return true;\n    }\n};\n\nconst {defaultOptions, props} = require(\"./x2j\");\nconst {buildOptions} = require(\"./util\");\nconst convertToNimn = (node, e_schema, options) => {\n    options = buildOptions(options,defaultOptions,props);\n    return _e(node, e_schema, options);\n};\n\nmodule.exports = {convertToNimn};\n","class XmlNode {\n    constructor(tagname, parent, val) {\n        this.tagname = tagname;\n        this.parent = parent;\n\n        this.child = {}; //child tags\n        this.attrsMap = {}; //attributes map\n\n        this.val = val;//text only\n    }\n\n    addChild(child) {\n        if (this.child[child.tagname]) {//already presents\n            this.child[child.tagname].push(child);\n        } else {\n            this.child[child.tagname] = [child];\n        }\n    }\n}\n\nmodule.exports = {XmlNode};\n","const {getTraversalObj} = require(\"./x2j\");\nconst {convertToNimn} = require(\"./nimn-data\");\nconst {validate} = require(\"./validator\");\nconst {Parser: j2xParser, isAttribute} = require(\"./j2x\");\nconst {defaultOptions,props} = require(\"./x2j\");\nconst {convertToJson} = require(\"./n2j\");\nconst {convertToJsonString} = require(\"./n2j-str\");\nconst {buildOptions} = require(\"./util\");\n\nconst parseToNimn = (xmlData, schema, options) => convertToNimn(getTraversalObj(xmlData, options), schema, options);\n\nconst parse = (xmlData, options) => {\n    options = buildOptions(options,defaultOptions,props);\n    return convertToJson(getTraversalObj(xmlData, options), options);\n};\n\nmodule.exports = {\n    parse,\n    parseToNimn,\n    convertToJson,\n    convertToJsonString,\n    convertToNimn,\n    getTraversalObj,\n    validate,\n    isAttribute,\n    j2xParser\n};\n"],"sourceRoot":""}