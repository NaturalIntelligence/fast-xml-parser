{"version":3,"sources":["webpack://parser/webpack/bootstrap","webpack://parser/./src/util.js","webpack://parser/./src/x2j.js","webpack://parser/./src/n2j-str.js","webpack://parser/./src/n2j.js","webpack://parser/./src/j2x.js","webpack://parser/./src/validator.js","webpack://parser/./src/nimn-data.js","webpack://parser/./src/xml-node.js","webpack://parser/./src/parser.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","isExist","v","doesMatch","string","regex","match","exec","getValue","merge","target","source","_arr","keys","_i","length","key","isEmptyObject","obj","doesNotMatch","getAllMatches","matches","push","_toConsumableArray","util","XmlNode","TagType","OPENING","CLOSING","SELF","CDATA","defaultOptions","attributeNamePrefix","attrNodeName","textNodeName","ignoreAttributes","ignoreNameSpace","allowBooleanAttributes","parseNodeValue","parseAttributeValue","arrayMode","trimValues","cdataTagName","cdataPositionChar","tagValueProcessor","a","attrValueProcessor","processTagValue","val","options","trim","parseValue","resolveNameSpace","tagname","tags","split","prefix","charAt","shouldParse","isNaN","indexOf","parseFloat","parseInt","attrsRegx","RegExp","buildAttributesMap","attrStr","replace","attrs","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","attrName","err","return","attrCollection","getTraversalObj","xmlData","assign","xmlObj","currentNode","tagsRegx","tag","nextTag","tagType","substr","parent","childNode","attrsMap","addChild","xmlToNodeobj","_cToJsonStr","node","level","jObj","child","_arr2","_i2","convertToJsonString","indentBy","convertToJson","format","supressEmptyNode","Parser","_classCallCheck","this","isAttribute","attrPrefixLen","isCDATA","replaceCDATAstr","replaceCDATAarr","indentate","tagEndChar","newLine","buildTextNode","buildEmptyTextNode","buildObjNode","buildEmptyObjNode","buildTextValNode","buildObjectNode","j2x","_typeof","attr","Array","isArray","item","result","attrKey","str","cdata","join","_arr3","_i3","repeat","startsWith","readPI","start","tagName","code","msg","readCommentAndCDATA","angleBracketsCount","doubleQuote","singleQuote","readAttributeStr","startChar","index","validAttrStrRegxp","validateAttributeString","attrNames","validateAttrName","validAttrRegxp","validate","props","buildOptions","tagFound","closingTag","substring","isValid","otg","pop","JSON","stringify","char","String","fromCharCode","chars","nilChar","missingChar","nilPremitive","missingPremitive","emptyChar","emptyValue","boundryChar","arrayEnd","objStart","arrStart","charsArr","processValue","isAppChar","ch","hasData","convertToNimn","e_schema","_e","hasValidData","itemSchema","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","j2xParser","parse","parseToNimn","schema"],"mappings":"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","file":"./parser.browser.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n","const getAllMatches = (string, regex) => {\n    const matches = [];\n    let match;\n    while ((match = regex.exec(string)) !== null) {\n        matches.push([...match]);\n    }\n    return matches;\n};\n\n/**\n * Copy all the properties of a into b.\n * @param {*} target\n * @param {*} source\n */\nconst merge = (target, source) => {\n    if (source) {\n        for (let key of Object.keys(source)) {\n            target[key] = source[key];\n        }\n    }\n    return target;\n};\n\nconst isEmptyObject = (obj) => Object.keys(obj).length === 0;\nconst isExist = (v) => typeof v !== \"undefined\";\n\nconst doesMatch = (string, regex) => {\n    const match = regex.exec(string);\n    return !(match === null || !isExist(match));\n};\n\nconst doesNotMatch = (string, regex) => !doesMatch(string, regex);\n\nconst getValue = (v) => isExist(v) ? v : \"\";\n\n// const fakeCall = function(a) {return a;};\n// const fakeCallNoReturn = function() {};\nmodule.exports = {\n    getValue,\n    merge,\n    isEmptyObject,\n    isExist,\n    doesMatch,\n    doesNotMatch,\n    getAllMatches\n};\n","const util = require(\"./util\");\nconst {XmlNode} = require(\"./xml-node\");\nconst TagType = {\"OPENING\": 1, \"CLOSING\": 2, \"SELF\": 3, \"CDATA\": 4};\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\n//treat cdata as a tag\n\nconst defaultOptions = {\n    attributeNamePrefix: \"@_\",\n    attrNodeName: false,\n    textNodeName: \"#text\",\n    ignoreAttributes: true,\n    ignoreNameSpace: false,\n    allowBooleanAttributes: false,         //a tag can have attributes without any value\n    //ignoreRootElement : false,\n    parseNodeValue: true,\n    parseAttributeValue: false,\n    arrayMode: false,\n    trimValues: true,                                //Trim string values of tag and attributes\n    cdataTagName: false,\n    cdataPositionChar: \"\\\\c\",\n    tagValueProcessor: (a) => a,\n    attrValueProcessor: (a) => a\n    //decodeStrict: false,\n};\n\nconst getTraversalObj = (xmlData, options) => {\n    //options = buildOptions(options);\n    options = Object.assign({}, defaultOptions, options);\n    //xmlData = xmlData.replace(/\\r?\\n/g, \" \");//make it single line\n    xmlData = xmlData.replace(/<!--[\\s\\S]*?-->/g, \"\");//Remove  comments\n\n    const xmlObj = new XmlNode(\"!xml\");\n    let currentNode = xmlObj;\n\n    const tagsRegx = /<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|(([\\w:\\-._]*:)?([\\w:\\-._]+))([^>]*)>|((\\/)(([\\w:\\-._]*:)?([\\w:\\-._]+))>))([^<]*)/g;\n    let tag = tagsRegx.exec(xmlData);\n    let nextTag = tagsRegx.exec(xmlData);\n    while (tag) {\n        const tagType = checkForTagType(tag);\n\n        if (tagType === TagType.CLOSING) {\n            //add parsed data to parent node\n            if (currentNode.parent && tag[14]) {\n                currentNode.parent.val = util.getValue(currentNode.parent.val) + \"\" + processTagValue(tag[14], options);\n            }\n\n            currentNode = currentNode.parent;\n        } else if (tagType === TagType.CDATA) {\n            if (options.cdataTagName) {\n                //add cdata node\n                const childNode = new XmlNode(options.cdataTagName, currentNode, tag[3]);\n                childNode.attrsMap = buildAttributesMap(tag[8], options);\n                currentNode.addChild(childNode);\n                //for backtracking\n                currentNode.val = util.getValue(currentNode.val) + options.cdataPositionChar;\n                //add rest value to parent node\n                if (tag[14]) {\n                    currentNode.val += processTagValue(tag[14], options);\n                }\n            } else {\n                currentNode.val = (currentNode.val || \"\") + (tag[3] || \"\") + processTagValue(tag[14], options);\n            }\n        } else if (tagType === TagType.SELF) {\n            const childNode = new XmlNode(options.ignoreNameSpace ? tag[7] : tag[5], currentNode, \"\");\n            if (tag[8] && tag[8].length > 1) {\n                tag[8] = tag[8].substr(0, tag[8].length - 1);\n            }\n            childNode.attrsMap = buildAttributesMap(tag[8], options);\n            currentNode.addChild(childNode);\n        } else {//TagType.OPENING\n            const childNode = new XmlNode(options.ignoreNameSpace ? tag[7] : tag[5], currentNode, processTagValue(tag[14], options));\n            childNode.attrsMap = buildAttributesMap(tag[8], options);\n            currentNode.addChild(childNode);\n            currentNode = childNode;\n        }\n\n        tag = nextTag;\n        nextTag = tagsRegx.exec(xmlData);\n    }\n\n    return xmlObj;\n};\n\nfunction processTagValue(val, options) {\n    if (val) {\n        if (options.trimValues) {\n            val = val.trim();\n        }\n        val = options.tagValueProcessor(val);\n        val = parseValue(val, options.parseNodeValue);\n    }\n\n    return val;\n}\n\nfunction checkForTagType(match) {\n    if (match[4] === \"]]>\") {\n        return TagType.CDATA;\n    } else if (match[10] === \"/\") {\n        return TagType.CLOSING;\n    } else if (typeof match[8] !== \"undefined\" && match[8].substr(match[8].length - 1) === \"/\") {\n        return TagType.SELF;\n    } else {\n        return TagType.OPENING;\n    }\n}\n\nfunction resolveNameSpace(tagname, options) {\n    if (options.ignoreNameSpace) {\n        const tags = tagname.split(\":\");\n        const prefix = tagname.charAt(0) === \"/\" ? \"/\" : \"\";\n        if (tags[0] === \"xmlns\") {\n            return \"\";\n        }\n        if (tags.length === 2) {\n            tagname = prefix + tags[1];\n        }\n    }\n    return tagname;\n}\n\nfunction parseValue(val, shouldParse) {\n    if (shouldParse && typeof val === \"string\") {\n        if (val.trim() === \"\" || isNaN(val)) {\n            val = val === \"true\" ? true : val === \"false\" ? false : val;\n        } else {\n            if (val.indexOf(\".\") !== -1) {\n                val = parseFloat(val);\n            } else {\n                val = parseInt(val, 10);\n            }\n        }\n        return val;\n    }\n    if (util.isExist(val)) {\n        return val;\n    }\n    return \"\";\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp(\"([^\\\\s=]+)\\\\s*(=\\\\s*(['\\\"])(.*?)\\\\3)?\", \"g\");\n\nfunction buildAttributesMap(attrStr, options) {\n    if (!options.ignoreAttributes && typeof attrStr === \"string\") {\n        attrStr = attrStr.replace(/\\r?\\n/g, \" \");\n        //attrStr = attrStr || attrStr.trim();\n\n        const matches = util.getAllMatches(attrStr, attrsRegx);\n        const attrs = {};\n        for (let match of matches) {\n            const attrName = resolveNameSpace(match[1], options);\n            if (attrName.length) {\n                if (match[4] !== undefined) {\n                    if (options.trimValues) {\n                        match[4] = match[4].trim();\n                    }\n                    match[4] = options.attrValueProcessor(match[4]);\n                    attrs[options.attributeNamePrefix + attrName] = parseValue(match[4], options.parseAttributeValue);\n                } else if (options.allowBooleanAttributes) {\n                    attrs[options.attributeNamePrefix + attrName] = true;\n                }\n\n            }\n        }\n        if (!Object.keys(attrs).length) {\n            return;\n        }\n        if (options.attrNodeName) {\n            const attrCollection = {};\n            attrCollection[options.attrNodeName] = attrs;\n            return attrCollection;\n        }\n        return attrs;\n    }\n}\n\nmodule.exports = {\n    defaultOptions,\n    getTraversalObj\n};\n","\"use strict\";\n\nconst {isEmptyObject, isExist, merge} = require(\"./util\");\nconst xmlToNodeobj = require(\"./x2j\");\n\n//TODO: do it later\nconst convertToJsonString = function(node, options) {\n    options = Object.assign({}, xmlToNodeobj.defaultOptions, options);\n\n    options.indentBy = options.indentBy || \"\";\n    return _cToJsonStr(node, options, 0);\n};\n\nconst _cToJsonStr = function(node, options, level) {\n    let jObj = \"{\";\n\n    //traver through all the children\n    for (let tagname of Object.keys(node.child)) {\n        if (node.child[tagname] && node.child[tagname].length > 1) {\n            jObj += \"\\\"\" + tagname + \"\\\" : [ \";\n            for (let tag of Object.keys(node.child[tagname])) {\n                jObj += _cToJsonStr(node.child[tagname][tag], options) + \" , \";\n            }\n            jObj = jObj.substr(0, jObj.length - 1) + \" ] \"; //remove extra comma in last\n        } else {\n            jObj += \"\\\"\" + tagname + \"\\\" : \" + _cToJsonStr(node.child[tagname][0], options) + \" ,\";\n        }\n    }\n    merge(jObj, node.attrsMap);\n    //add attrsMap as new children\n    if (isEmptyObject(jObj)) {\n        return isExist(node.val) ? node.val : \"\";\n    } else {\n        if (isExist(node.val)) {\n            if (!(typeof node.val === \"string\" && (node.val === \"\" || node.val === options.cdataPositionChar))) {\n                jObj += \"\\\"\" + options.textNodeName + \"\\\" : \" + stringval(node.val);\n            }\n        }\n    }\n    //add value\n    if (jObj[jObj.length - 1] === \",\") {\n        jObj = jObj.substr(0, jObj.length - 2);\n    }\n    return jObj + \"}\";\n};\n\nfunction stringval(v) {\n    if (v === true || v === false || !isNaN(v)) {\n        return v;\n    } else {\n        return \"\\\"\" + v + \"\\\"\";\n    }\n}\n\nfunction indentate(options, level) {\n    return options.indentBy.repeat(level);\n}\n\nmodule.exports = {convertToJsonString};\n","const {isEmptyObject, merge, isExist} = require(\"./util\");\n\nconst convertToJson = function(node, options) {\n    const jObj = {};\n\n    if ((!node.child || isEmptyObject(node.child)) && (!node.attrsMap || isEmptyObject(node.attrsMap))) {\n        return isExist(node.val) ? node.val : \"\";\n    } else {\n        if (isExist(node.val)) {\n            if (!(typeof node.val === \"string\" && (node.val === \"\" || node.val === options.cdataPositionChar))) {\n                jObj[options.textNodeName] = node.val;\n            }\n        }\n    }\n\n    merge(jObj, node.attrsMap);\n\n    for (let tagname of  Object.keys(node.child)) {\n        if (node.child[tagname] && node.child[tagname].length > 1) {\n            jObj[tagname] = [];\n            for (let tag of Object.keys(node.child[tagname])) {\n                jObj[tagname].push(convertToJson(node.child[tagname][tag], options));\n            }\n        } else {\n            jObj[tagname] = convertToJson(node.child[tagname][0], options);\n        }\n    }\n\n    //add value\n    return jObj;\n};\n\nmodule.exports = {convertToJson};\n","const {isExist} = require(\"./util\");\n\nconst defaultOptions = {\n    attributeNamePrefix: \"@_\",\n    attrNodeName: false,\n    textNodeName: \"#text\",\n    ignoreAttributes: true,\n    cdataTagName: false,\n    cdataPositionChar: \"\\\\c\",\n    format: false,\n    indentBy: \"  \",\n    supressEmptyNode: false,\n    tagValueProcessor: (a) => a,\n    attrValueProcessor: (a) => a\n};\n\nclass Parser {\n    constructor(options) {\n        this.options = Object.assign({}, defaultOptions, options);\n        if (this.options.ignoreAttributes || this.options.attrNodeName) {\n            this.isAttribute = function(/*a*/) { return false;};\n        } else {\n            this.attrPrefixLen = this.options.attributeNamePrefix.length;\n            this.isAttribute = isAttribute;\n        }\n        if (this.options.cdataTagName) {\n            this.isCDATA = isCDATA;\n        } else {\n            this.isCDATA = function(/*a*/) { return false;};\n        }\n        this.replaceCDATAstr = replaceCDATAstr;\n        this.replaceCDATAarr = replaceCDATAarr;\n\n        if (this.options.format) {\n            this.indentate = indentate;\n            this.tagEndChar = \">\\n\";\n            this.newLine = \"\\n\";\n        } else {\n            this.indentate = () => \"\";\n            this.tagEndChar = \">\";\n            this.newLine = \"\";\n        }\n\n        if (this.options.supressEmptyNode) {\n            this.buildTextNode = buildEmptyTextNode;\n            this.buildObjNode = buildEmptyObjNode;\n        } else {\n            this.buildTextNode = buildTextValNode;\n            this.buildObjNode = buildObjectNode;\n        }\n\n        this.buildTextValNode = buildTextValNode;\n        this.buildObjectNode = buildObjectNode;\n    }\n\n    parse(jObj) {\n        return this.j2x(jObj, 0).val;\n    }\n\n    j2x(jObj, level) {\n        let attrStr = \"\";\n        let val = \"\";\n        for (let key of Object.keys(jObj)) {\n            if (!isExist(jObj[key])) {\n                // supress undefined node\n            }\n            else if (typeof jObj[key] !== \"object\") {//premitive type\n                const attr = this.isAttribute(key);\n                if (attr) {\n                    attrStr += \" \" + attr + \"=\\\"\" + this.options.attrValueProcessor(\"\" + jObj[key]) + \"\\\"\";\n                } else if (this.isCDATA(key)) {\n                    if (jObj[this.options.textNodeName]) {\n                        val += this.replaceCDATAstr(jObj[this.options.textNodeName], jObj[key]);\n                    } else {\n                        val += this.replaceCDATAstr(\"\", jObj[key]);\n                    }\n                } else {//tag value\n                    if (key === this.options.textNodeName) {\n                        if (jObj[this.options.cdataTagName]) {\n                            //value will added while processing cdata\n                        } else {\n                            val += this.options.tagValueProcessor(\"\" + jObj[key]);\n                        }\n                    } else {\n                        val += this.buildTextNode(jObj[key], key, \"\", level);\n                    }\n                }\n            } else if (Array.isArray(jObj[key])) {//repeated nodes\n                if (this.isCDATA(key)) {\n                    if (jObj[this.options.textNodeName]) {\n                        val += this.replaceCDATAarr(jObj[this.options.textNodeName], jObj[key]);\n                    } else {\n                        val += this.replaceCDATAarr(\"\", jObj[key]);\n                    }\n                } else {//nested nodes\n                    for (let item of jObj[key]) {\n                        if (!isExist(item)) {\n                            // supress undefined node\n                        }\n                        else if (typeof item === \"object\") {\n                            const result = this.j2x(item, level + 1);\n                            val += this.buildObjNode(result.val, key, result.attrStr, level);\n                        } else {\n                            val += this.buildTextNode(item, key, \"\", level);\n                        }\n                    }\n                }\n            } else {\n                if (this.options.attrNodeName && key === this.options.attrNodeName) {\n                    for (let attrKey of Object.keys(jObj[key])) {\n                        attrStr += \" \" + attrKey + \"=\\\"\" + this.options.tagValueProcessor(\"\" + jObj[key][attrKey]) + \"\\\"\";\n                    }\n                } else {\n                    const result = this.j2x(jObj[key], level + 1);\n                    val += this.buildObjNode(result.val, key, result.attrStr, level);\n                }\n            }\n        }\n        return {attrStr: attrStr, val: val};\n    }\n}\n\nfunction replaceCDATAstr(str, cdata) {\n    str = this.options.tagValueProcessor(\"\" + str);\n    if (this.options.cdataPositionChar === \"\" || str === \"\") {\n        return str + \"<![CDATA[\" + cdata + \"]]>\";\n    } else {\n        return str.replace(this.options.cdataPositionChar, \"<![CDATA[\" + cdata + \"]]>\");\n    }\n}\n\nfunction replaceCDATAarr(str, cdata) {\n    str = this.options.tagValueProcessor(\"\" + str);\n    if (this.options.cdataPositionChar === \"\" || str === \"\") {\n        return str + \"<![CDATA[\" + cdata.join(\"]]><![CDATA[\") + \"]]>\";\n    } else {\n        for (const v of Object.keys(cdata)) {\n            str = str.replace(this.options.cdataPositionChar, \"<![CDATA[\" + cdata[v] + \"]]>\");\n        }\n        return str;\n    }\n}\n\nfunction buildObjectNode(val, key, attrStr, level) {\n    return this.indentate(level)\n           + \"<\" + key + attrStr\n           + this.tagEndChar\n           + val\n           //+ this.newLine\n           + this.indentate(level)\n           + \"</\" + key + this.tagEndChar;\n}\n\nfunction buildEmptyObjNode(val, key, attrStr, level) {\n    if (val !== \"\") {\n        return this.buildObjectNode(val, key, attrStr, level);\n    } else {\n        return this.indentate(level)\n               + \"<\" + key + attrStr\n               + \"/\"\n               + this.tagEndChar;\n        //+ this.newLine\n    }\n}\n\nfunction buildTextValNode(val, key, attrStr, level) {\n    return this.indentate(level) + \"<\" + key + attrStr + \">\" + this.options.tagValueProcessor(\"\" + val) + \"</\" + key + this.tagEndChar;\n}\n\nfunction buildEmptyTextNode(val, key, attrStr, level) {\n    if (val !== \"\") {\n        return this.buildTextValNode(val, key, attrStr, level);\n    } else {\n        return this.indentate(level) + \"<\" + key + attrStr + \"/\" + this.tagEndChar;\n    }\n}\n\nfunction indentate(level) {\n    return this.options.indentBy.repeat(level);\n}\n\nfunction isAttribute(name/*, options*/) {\n    if (name.startsWith(this.options.attributeNamePrefix)) {\n        return name.substr(this.attrPrefixLen);\n    } else {\n        return false;\n    }\n}\n\nfunction isCDATA(name) {\n    return name === this.options.cdataTagName;\n}\n\n//formatting\n//indentation\n//\\n after each closing or self closing tag\n\nmodule.exports = {Parser, isAttribute};\n","const util = require(\"./util\");\n\nconst defaultOptions = {\n    allowBooleanAttributes: false         //A tag can have attributes without any value\n};\n\nconst buildOptions = (options) => {\n    if (!options) {\n        options = {};\n    }\n    const props = [\"allowBooleanAttributes\"];\n    for (let i of props) {\n        if (options[props[i]] === undefined) {\n            options[props[i]] = defaultOptions[props[i]];\n        }\n    }\n    return options;\n};\n\n//const tagsPattern = new RegExp(\"<\\\\/?([\\\\w:\\\\-_\\.]+)\\\\s*\\/?>\",\"g\");\nconst validate = (xmlData, options) => {\n    options = buildOptions(options);\n\n    //xmlData = xmlData.replace(/(\\r\\n|\\n|\\r)/gm,\"\");//make it single line\n    //xmlData = xmlData.replace(/(^\\s*<\\?xml.*?\\?>)/g,\"\");//Remove XML starting tag\n    //xmlData = xmlData.replace(/(<!DOCTYPE[\\s\\w\\\"\\.\\/\\-\\:]+(\\[.*\\])*\\s*>)/g,\"\");//Remove DOCTYPE\n\n    const tags = [];\n    let tagFound = false;\n    for (let i = 0; i < xmlData.length; i++) {\n\n        if (xmlData[i] === \"<\") {//starting of tag\n            //read until you reach to '>' avoiding any '>' in attribute value\n            i++;\n            if (xmlData[i] === \"?\") {\n                i = readPI(xmlData, ++i);\n                if (i.err) {\n                    return i;\n                }\n            } else if (xmlData[i] === \"!\") {\n                i = readCommentAndCDATA(xmlData, i);\n                continue;\n            } else {\n                let closingTag = false;\n                if (xmlData[i] === \"/\") {//closing tag\n                    closingTag = true;\n                    i++;\n                }\n                //read tagname\n                let tagName = \"\";\n                for (; i < xmlData.length &&\n                       xmlData[i] !== \">\" &&\n                       xmlData[i] !== \" \" &&\n                       xmlData[i] !== \"\\t\"; i++) {\n\n                    tagName += xmlData[i];\n                }\n                tagName = tagName.trim();\n                //console.log(tagName);\n\n                if (tagName[tagName.length - 1] === \"/\") {//self closing tag without attributes\n                    tagName = tagName.substring(0, tagName.length - 1);\n                    continue;\n                }\n                if (!validateTagName(tagName)) {\n                    return {err: {code: \"InvalidTag\", msg: \"Tag \" + tagName + \" is an invalid name.\"}};\n                }\n\n                const result = readAttributeStr(xmlData, i);\n                if (result === false) {\n                    return {err: {code: \"InvalidAttr\", msg: \"Attributes for \" + tagName + \" have open quote\"}};\n                }\n                let attrStr = result.value;\n                i = result.index;\n\n                if (attrStr[attrStr.length - 1] === \"/\") {//self closing tag\n                    attrStr = attrStr.substring(0, attrStr.length - 1);\n                    const isValid = validateAttributeString(attrStr, options);\n                    if (isValid === true) {\n                        tagFound = true;\n                        continue;\n                    } else {\n                        return isValid;\n                    }\n                } else if (closingTag) {\n                    if (attrStr.trim().length > 0) {\n                        return {err: {code: \"InvalidTag\", msg: \"closing tag \" + tagName + \" can't have attributes or invalid starting.\"}};\n                    } else {\n                        const otg = tags.pop();\n                        if (tagName !== otg) {\n                            return {err: {code: \"InvalidTag\", msg: \"closing tag \" + otg + \" is expected inplace of \" + tagName + \".\"}};\n                        }\n                    }\n                } else {\n                    const isValid = validateAttributeString(attrStr, options);\n                    if (isValid !== true) {\n                        return isValid;\n                    }\n                    tags.push(tagName);\n                    tagFound = true;\n                }\n\n                //skip tag text value\n                //It may include comments and CDATA value\n                for (i++; i < xmlData.length; i++) {\n                    if (xmlData[i] === \"<\") {\n                        if (xmlData[i + 1] === \"!\") {//comment or CADATA\n                            i++;\n                            i = readCommentAndCDATA(xmlData, i);\n                            continue;\n                        } else {\n                            break;\n                        }\n                    }\n                }//end of reading tag text value\n                if (xmlData[i] === \"<\") {\n                    i--;\n                }\n            }\n        } else {\n            if (xmlData[i] === \" \" || xmlData[i] === \"\\t\" || xmlData[i] === \"\\n\" || xmlData[i] === \"\\r\") {\n                continue;\n            }\n            return {err: {code: \"InvalidChar\", msg: \"char \" + xmlData[i] + \" is not expected .\"}};\n        }\n    }\n\n    if (!tagFound) {\n        return {err: {code: \"InvalidXml\", msg: \"Start tag expected.\"}};\n    } else if (tags.length > 0) {\n        return {err: {code: \"InvalidXml\", msg: \"Invalid \" + JSON.stringify(tags, null, 4).replace(/\\r?\\n/g, \"\") + \" found.\"}};\n    }\n\n    return true;\n};\n\n/**\n * Read Processing insstructions and skip\n * @param {*} xmlData\n * @param {*} i\n */\nfunction readPI(xmlData, i) {\n    const start = i;\n    for (; i < xmlData.length; i++) {\n        if (xmlData[i] === \"?\" || xmlData[i] === \" \") { //tagName\n            const tagName = xmlData.substr(start, i - start);\n            if (i > 5 && tagName === \"xml\") {\n                return {err: {code: \"InvalidXml\", msg: \"XML declaration allowed only at the start of the document.\"}};\n            } else if (xmlData[i] === \"?\" && xmlData[i + 1] === \">\") {\n                //check if valid attribute string\n                i++;\n                break;\n            } else {\n                continue;\n            }\n        }\n    }\n    return i;\n}\n\nfunction readCommentAndCDATA(xmlData, i) {\n    if (xmlData.length > i + 5 && xmlData[i + 1] === \"-\" && xmlData[i + 2] === \"-\") {//comment\n        for (i += 3; i < xmlData.length; i++) {\n            if (xmlData[i] === \"-\" && xmlData[i + 1] === \"-\" && xmlData[i + 2] === \">\") {\n                i += 2;\n                break;\n            }\n        }\n    } else if (xmlData.length > i + 8 &&\n               xmlData[i + 1] === \"D\" &&\n               xmlData[i + 2] === \"O\" &&\n               xmlData[i + 3] === \"C\" &&\n               xmlData[i + 4] === \"T\" &&\n               xmlData[i + 5] === \"Y\" &&\n               xmlData[i + 6] === \"P\" &&\n               xmlData[i + 7] === \"E\") {\n        let angleBracketsCount = 1;\n        for (i += 8; i < xmlData.length; i++) {\n            if (xmlData[i] === \"<\") {angleBracketsCount++;}\n            else if (xmlData[i] === \">\") {\n                angleBracketsCount--;\n                if (angleBracketsCount === 0) {\n                    break;\n                }\n            }\n        }\n    } else if (xmlData.length > i + 9 &&\n               xmlData[i + 1] === \"[\" &&\n               xmlData[i + 2] === \"C\" &&\n               xmlData[i + 3] === \"D\" &&\n               xmlData[i + 4] === \"A\" &&\n               xmlData[i + 5] === \"T\" &&\n               xmlData[i + 6] === \"A\" &&\n               xmlData[i + 7] === \"[\") {\n\n        for (i += 8; i < xmlData.length; i++) {\n            if (xmlData[i] === \"]\" && xmlData[i + 1] === \"]\" && xmlData[i + 2] === \">\") {\n                i += 2;\n                break;\n            }\n        }\n    }\n\n    return i;\n}\n\nconst doubleQuote = \"\\\"\";\nconst singleQuote = \"'\";\n\n/**\n * Keep reading xmlData until '<' is found outside the attribute value.\n * @param {string} xmlData\n * @param {number} i\n */\nfunction readAttributeStr(xmlData, i) {\n    let attrStr = \"\";\n    let startChar = \"\";\n    for (; i < xmlData.length; i++) {\n        if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\n            if (startChar === \"\") {\n                startChar = xmlData[i];\n            } else if (startChar !== xmlData[i]) {\n                //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa\n                continue;\n            } else {\n                startChar = \"\";\n            }\n        } else if (xmlData[i] === \">\") {\n            if (startChar === \"\") {\n                break;\n            }\n        }\n        attrStr += xmlData[i];\n    }\n    if (startChar !== \"\") {\n        return false;\n    }\n\n    return {value: attrStr, index: i};\n}\n\n/**\n * Select all the attributes whether valid or invalid.\n */\nconst validAttrStrRegxp = new RegExp(\"(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*(['\\\"])(([\\\\s\\\\S])*?)\\\\5)?\", \"g\");\n\n//attr, =\"sd\", a=\"amit's\", a=\"sd\"b=\"saf\", ab  cd=\"\"\n\nfunction validateAttributeString(attrStr, options) {\n    //console.log(\"start:\"+attrStr+\":end\");\n\n    //if(attrStr.trim().length === 0) return true; //empty string\n\n    const matches = util.getAllMatches(attrStr, validAttrStrRegxp);\n    const attrNames = [];\n\n    for (let match of matches) {\n        //console.log(matches[i]);\n\n        if (match[1].length === 0) {//nospace before attribute name: a=\"sd\"b=\"saf\"\n            return {err: {code: \"InvalidAttr\", msg: \"attribute \" + match[2] + \" has no space in starting.\"}};\n        } else if (match[3] === undefined && !options.allowBooleanAttributes) {//independent attribute: ab\n            return {err: {code: \"InvalidAttr\", msg: \"boolean attribute \" + match[2] + \" is not allowed.\"}};\n        }\n        /* else if(matches[i][6] === undefined){//attribute without value: ab=\n                    return { err: { code:\"InvalidAttr\",msg:\"attribute \" + matches[i][2] + \" has no value assigned.\"}};\n                } */\n        const attrName = match[2];\n        if (!validateAttrName(attrName)) {\n            return {err: {code: \"InvalidAttr\", msg: \"attribute \" + attrName + \" is an invalid name.\"}};\n        }\n        if (!attrNames.hasOwnProperty(attrName)) {//check for duplicate attribute.\n            attrNames[attrName] = 1;\n        } else {\n            return {err: {code: \"InvalidAttr\", msg: \"attribute \" + attrName + \" is repeated.\"}};\n        }\n    }\n\n    return true;\n\n}\n\nconst validAttrRegxp = /^[_a-zA-Z][\\w\\-.:]*$/;\n\nfunction validateAttrName(attrName) {\n    return util.doesMatch(attrName, validAttrRegxp);\n}\n\n//const startsWithXML = new RegExp(\"^[Xx][Mm][Ll]\");\nconst startsWith = /^([a-zA-Z]|_)[\\w.\\-_:]*/;\n\nfunction validateTagName(tagname) {\n    /*if(util.doesMatch(tagname,startsWithXML)) return false;\n    else*/\n    return !util.doesNotMatch(tagname, startsWith);\n}\n\nmodule.exports = {validate};\n","const char = (a) => String.fromCharCode(a);\n\nconst chars = {\n    nilChar: char(254),\n    missingChar: char(200),\n    nilPremitive: char(176),\n    missingPremitive: char(201),\n    emptyChar: char(177),\n    emptyValue: char(178),\n    boundryChar: char(186),\n    arrayEnd: char(197),\n    objStart: char(198),\n    arrStart: char(199)\n};\n\nconst charsArr = [\n    chars.nilChar,\n    chars.nilPremitive,\n    chars.missingChar,\n    chars.missingPremitive,\n    chars.boundryChar,\n    chars.emptyChar,\n    chars.arrayEnd,\n    chars.objStart,\n    chars.arrStart\n];\n\nconst _e = (node, e_schema, options) => {\n    if (typeof e_schema === \"string\") {//premitive\n        if (node && node[0] && node[0].val !== undefined) {\n            return getValue(node[0].val, e_schema);\n        } else {\n            return getValue(node, e_schema);\n        }\n    } else {\n        const hasValidData = hasData(node);\n        if (hasValidData === true) {\n            let str = \"\";\n            if (Array.isArray(e_schema)) {\n                //attributes can't be repeated. hence check in children tags only\n                str += chars.arrStart;\n                const itemSchema = e_schema[0];\n                //var itemSchemaType = itemSchema;\n                if (typeof itemSchema === \"string\") {\n                    for (let item of node) {\n                        const r = getValue(item.val, itemSchema);\n                        str = processValue(str, r);\n                    }\n                } else {\n                    for (let item of node) {\n                        const r = _e(item, itemSchema, options);\n                        str = processValue(str, r);\n                    }\n                }\n                str += chars.arrayEnd;//indicates that next item is not array item\n            } else {//object\n                str += chars.objStart;\n                if (Array.isArray(node)) {\n                    node = node[0];\n                }\n                for (let key of Object.keys(e_schema)) {\n                    //a property defined in schema can be present either in attrsMap or children tags\n                    //options.textNodeName will not present in both maps, take it's value from val\n                    //options.attrNodeName will be present in attrsMap\n                    let r;\n                    if (!options.ignoreAttributes && node.attrsMap && node.attrsMap[key]) {\n                        r = _e(node.attrsMap[key], e_schema[key], options);\n                    } else if (key === options.textNodeName) {\n                        r = _e(node.val, e_schema[key], options);\n                    } else {\n                        r = _e(node.child[key], e_schema[key], options);\n                    }\n                    str = processValue(str, r);\n                }\n            }\n            return str;\n        } else {\n            return hasValidData;\n        }\n    }\n};\n\nconst getValue = (a/*, type*/) => {\n    switch (a) {\n        case undefined:\n            return chars.missingPremitive;\n        case null:\n            return chars.nilPremitive;\n        case \"\":\n            return chars.emptyValue;\n        default:\n            return a;\n    }\n};\n\nconst processValue = (str, r) => {\n    if (!isAppChar(r[0]) && !isAppChar(str[str.length - 1])) {\n        str += chars.boundryChar;\n    }\n    return str + r;\n};\n\nconst isAppChar = (ch) => {\n    return charsArr.indexOf(ch) !== -1;\n};\n\nconst hasData = (jObj) => {\n    if (jObj === undefined) {\n        return chars.missingChar;\n    } else if (jObj === null) {\n        return chars.nilChar;\n    } else if (jObj.child && Object.keys(jObj.child).length === 0 && (!jObj.attrsMap || Object.keys(jObj.attrsMap).length === 0)) {\n        return chars.emptyChar;\n    } else {\n        return true;\n    }\n};\n\nconst {defaultOptions} = require(\"./x2j\");\nconst convertToNimn = (node, e_schema, options) => {\n    options = Object.assign({}, defaultOptions, options);\n    return _e(node, e_schema, options);\n};\n\nmodule.exports = {convertToNimn};\n","class XmlNode {\n    constructor(tagname, parent, val) {\n        this.tagname = tagname;\n        this.parent = parent;\n\n        this.child = {}; //child tags\n        this.attrsMap = {}; //attributes map\n\n        this.val = val;//text only\n    }\n\n    addChild(child) {\n        if (this.child[child.tagname]) {//already presents\n            this.child[child.tagname].push(child);\n        } else {\n            this.child[child.tagname] = [child];\n        }\n    }\n}\n\nmodule.exports = {XmlNode};\n","const {getTraversalObj} = require(\"./x2j\");\nconst {convertToNimn} = require(\"./nimn-data\");\nconst {validate} = require(\"./validator\");\nconst {Parser: j2xParser, isAttribute} = require(\"./j2x\");\nconst {defaultOptions} = require(\"./x2j\");\nconst {convertToJson} = require(\"./n2j\");\nconst {convertToJsonString} = require(\"./n2j-str\");\n\nconst parseToNimn = (xmlData, schema, options) => convertToNimn(getTraversalObj(xmlData, options), schema, options);\n\nconst parse = (xmlData, options) => {\n    options = Object.assign({}, defaultOptions, options);\n    return convertToJson(getTraversalObj(xmlData, options), options);\n};\n\nmodule.exports = {\n    parse,\n    parseToNimn,\n    convertToJson,\n    convertToJsonString,\n    convertToNimn,\n    getTraversalObj,\n    validate,\n    isAttribute,\n    j2xParser\n};\n"],"sourceRoot":""}