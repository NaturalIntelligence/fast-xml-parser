{"version":3,"sources":["webpack/bootstrap","./src/j2x.js","./src/n2j-str.js","./src/n2j.js","./src/nimn-data.js","./src/parser.js","./src/util.js","./src/validator.js","./src/x2j.js","./src/xml-node.js"],"names":["require","isExist","defaultOptions","attributeNamePrefix","attrNodeName","textNodeName","ignoreAttributes","cdataTagName","cdataPositionChar","format","indentBy","supressEmptyNode","tagValueProcessor","a","attrValueProcessor","Parser","options","Object","assign","isAttribute","attrPrefixLen","length","isCDATA","replaceCDATAstr","replaceCDATAarr","indentate","tagEndChar","newLine","buildTextNode","buildEmptyTextNode","buildObjNode","buildEmptyObjNode","buildTextValNode","buildObjectNode","jObj","j2x","val","level","attrStr","keys","key","attr","Array","isArray","item","result","attrKey","str","cdata","replace","join","v","repeat","name","startsWith","substr","module","exports","isEmptyObject","merge","xmlToNodeobj","convertToJsonString","node","_cToJsonStr","child","tagname","tag","attrsMap","stringval","isNaN","convertToJson","push","char","String","fromCharCode","chars","nilChar","missingChar","nilPremitive","missingPremitive","emptyChar","emptyValue","boundryChar","arrayEnd","objStart","arrStart","charsArr","_e","e_schema","undefined","getValue","hasValidData","hasData","itemSchema","r","processValue","isAppChar","ch","indexOf","convertToNimn","getTraversalObj","validate","j2xParser","parseToNimn","xmlData","schema","parse","getAllMatches","string","regex","matches","match","exec","target","source","obj","doesMatch","doesNotMatch","util","allowBooleanAttributes","buildOptions","props","i","tags","tagFound","readPI","err","readCommentAndCDATA","closingTag","tagName","trim","substring","validateTagName","code","msg","readAttributeStr","value","index","isValid","validateAttributeString","otg","pop","JSON","stringify","start","angleBracketsCount","doubleQuote","singleQuote","startChar","validAttrStrRegxp","RegExp","attrNames","attrName","validateAttrName","hasOwnProperty","validAttrRegxp","XmlNode","TagType","ignoreNameSpace","parseNodeValue","parseAttributeValue","arrayMode","trimValues","xmlObj","currentNode","tagsRegx","nextTag","tagType","checkForTagType","CLOSING","parent","processTagValue","CDATA","childNode","buildAttributesMap","addChild","SELF","parseValue","OPENING","resolveNameSpace","split","prefix","charAt","shouldParse","parseFloat","parseInt","attrsRegx","attrs","attrCollection"],"mappings":"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","file":"./parser.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading wasm modules\n \tvar installedWasmModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// object with all compiled WebAssembly.Modules\n \t__webpack_require__.w = {};\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/parser.js\");\n","const {isExist} = require(\"./util\");\n\nconst defaultOptions = {\n    attributeNamePrefix: \"@_\",\n    attrNodeName: false,\n    textNodeName: \"#text\",\n    ignoreAttributes: true,\n    cdataTagName: false,\n    cdataPositionChar: \"\\\\c\",\n    format: false,\n    indentBy: \"  \",\n    supressEmptyNode: false,\n    tagValueProcessor: function(a) {return a;},\n    attrValueProcessor: function(a) {return a;}\n};\n\nclass Parser {\n    constructor(options) {\n        this.options = Object.assign({}, defaultOptions, options);\n        if (this.options.ignoreAttributes || this.options.attrNodeName) {\n            this.isAttribute = function(/*a*/) { return false;};\n        } else {\n            this.attrPrefixLen = this.options.attributeNamePrefix.length;\n            this.isAttribute = isAttribute;\n        }\n        if (this.options.cdataTagName) {\n            this.isCDATA = isCDATA;\n        } else {\n            this.isCDATA = function(/*a*/) { return false;};\n        }\n        this.replaceCDATAstr = replaceCDATAstr;\n        this.replaceCDATAarr = replaceCDATAarr;\n\n        if (this.options.format) {\n            this.indentate = indentate;\n            this.tagEndChar = \">\\n\";\n            this.newLine = \"\\n\";\n        } else {\n            this.indentate = () => \"\";\n            this.tagEndChar = \">\";\n            this.newLine = \"\";\n        }\n\n        if (this.options.supressEmptyNode) {\n            this.buildTextNode = buildEmptyTextNode;\n            this.buildObjNode = buildEmptyObjNode;\n        } else {\n            this.buildTextNode = buildTextValNode;\n            this.buildObjNode = buildObjectNode;\n        }\n\n        this.buildTextValNode = buildTextValNode;\n        this.buildObjectNode = buildObjectNode;\n    }\n\n    parse(jObj) {\n        return this.j2x(jObj, 0).val;\n    }\n\n    j2x(jObj, level) {\n        let attrStr = \"\";\n        let val = \"\";\n        for (let key of Object.keys(jObj)) {\n            if (!isExist(jObj[key])) {\n                // supress undefined node\n            }\n            else if (typeof jObj[key] !== \"object\") {//premitive type\n                const attr = this.isAttribute(key);\n                if (attr) {\n                    attrStr += \" \" + attr + \"=\\\"\" + this.options.attrValueProcessor(\"\" + jObj[key]) + \"\\\"\";\n                } else if (this.isCDATA(key)) {\n                    if (jObj[this.options.textNodeName]) {\n                        val += this.replaceCDATAstr(jObj[this.options.textNodeName], jObj[key]);\n                    } else {\n                        val += this.replaceCDATAstr(\"\", jObj[key]);\n                    }\n                } else {//tag value\n                    if (key === this.options.textNodeName) {\n                        if (jObj[this.options.cdataTagName]) {\n                            //value will added while processing cdata\n                        } else {\n                            val += this.options.tagValueProcessor(\"\" + jObj[key]);\n                        }\n                    } else {\n                        val += this.buildTextNode(jObj[key], key, \"\", level);\n                    }\n                }\n            } else if (Array.isArray(jObj[key])) {//repeated nodes\n                if (this.isCDATA(key)) {\n                    if (jObj[this.options.textNodeName]) {\n                        val += this.replaceCDATAarr(jObj[this.options.textNodeName], jObj[key]);\n                    } else {\n                        val += this.replaceCDATAarr(\"\", jObj[key]);\n                    }\n                } else {//nested nodes\n                    for (let item of jObj[key]) {\n                        if (!isExist(item)) {\n                            // supress undefined node\n                        }\n                        else if (typeof item === \"object\") {\n                            const result = this.j2x(item, level + 1);\n                            val += this.buildObjNode(result.val, key, result.attrStr, level);\n                        } else {\n                            val += this.buildTextNode(item, key, \"\", level);\n                        }\n                    }\n                }\n            } else {\n                if (this.options.attrNodeName && key === this.options.attrNodeName) {\n                    for (let attrKey of Object.keys(jObj[key])) {\n                        attrStr += \" \" + attrKey + \"=\\\"\" + this.options.tagValueProcessor(\"\" + jObj[key][attrKey]) + \"\\\"\";\n                    }\n                } else {\n                    const result = this.j2x(jObj[key], level + 1);\n                    val += this.buildObjNode(result.val, key, result.attrStr, level);\n                }\n            }\n        }\n        return {attrStr: attrStr, val: val};\n    }\n}\n\nfunction replaceCDATAstr(str, cdata) {\n    str = this.options.tagValueProcessor(\"\" + str);\n    if (this.options.cdataPositionChar === \"\" || str === \"\") {\n        return str + \"<![CDATA[\" + cdata + \"]]>\";\n    } else {\n        return str.replace(this.options.cdataPositionChar, \"<![CDATA[\" + cdata + \"]]>\");\n    }\n}\n\nfunction replaceCDATAarr(str, cdata) {\n    str = this.options.tagValueProcessor(\"\" + str);\n    if (this.options.cdataPositionChar === \"\" || str === \"\") {\n        return str + \"<![CDATA[\" + cdata.join(\"]]><![CDATA[\") + \"]]>\";\n    } else {\n        for (const v of Object.keys(cdata)) {\n            str = str.replace(this.options.cdataPositionChar, \"<![CDATA[\" + cdata[v] + \"]]>\");\n        }\n        return str;\n    }\n}\n\nfunction buildObjectNode(val, key, attrStr, level) {\n    return this.indentate(level)\n           + \"<\" + key + attrStr\n           + this.tagEndChar\n           + val\n           //+ this.newLine\n           + this.indentate(level)\n           + \"</\" + key + this.tagEndChar;\n}\n\nfunction buildEmptyObjNode(val, key, attrStr, level) {\n    if (val !== \"\") {\n        return this.buildObjectNode(val, key, attrStr, level);\n    } else {\n        return this.indentate(level)\n               + \"<\" + key + attrStr\n               + \"/\"\n               + this.tagEndChar;\n        //+ this.newLine\n    }\n}\n\nfunction buildTextValNode(val, key, attrStr, level) {\n    return this.indentate(level) + \"<\" + key + attrStr + \">\" + this.options.tagValueProcessor(\"\" + val) + \"</\" + key + this.tagEndChar;\n}\n\nfunction buildEmptyTextNode(val, key, attrStr, level) {\n    if (val !== \"\") {\n        return this.buildTextValNode(val, key, attrStr, level);\n    } else {\n        return this.indentate(level) + \"<\" + key + attrStr + \"/\" + this.tagEndChar;\n    }\n}\n\nfunction indentate(level) {\n    return this.options.indentBy.repeat(level);\n}\n\nfunction isAttribute(name/*, options*/) {\n    if (name.startsWith(this.options.attributeNamePrefix)) {\n        return name.substr(this.attrPrefixLen);\n    } else {\n        return false;\n    }\n}\n\nfunction isCDATA(name) {\n    return name === this.options.cdataTagName;\n}\n\n//formatting\n//indentation\n//\\n after each closing or self closing tag\n\nmodule.exports = {Parser, isAttribute};\n","\"use strict\";\n\nconst {isEmptyObject, isExist, merge} = require(\"./util\");\nconst xmlToNodeobj = require(\"./x2j\");\n\n//TODO: do it later\nconst convertToJsonString = function(node, options) {\n    options = Object.assign({}, xmlToNodeobj.defaultOptions, options);\n\n    options.indentBy = options.indentBy || \"\";\n    return _cToJsonStr(node, options, 0);\n};\n\nconst _cToJsonStr = function(node, options, level) {\n    let jObj = \"{\";\n\n    //traver through all the children\n    for (let tagname of Object.keys(node.child)) {\n        if (node.child[tagname] && node.child[tagname].length > 1) {\n            jObj += \"\\\"\" + tagname + \"\\\" : [ \";\n            for (let tag of Object.keys(node.child[tagname])) {\n                jObj += _cToJsonStr(node.child[tagname][tag], options) + \" , \";\n            }\n            jObj = jObj.substr(0, jObj.length - 1) + \" ] \"; //remove extra comma in last\n        } else {\n            jObj += \"\\\"\" + tagname + \"\\\" : \" + _cToJsonStr(node.child[tagname][0], options) + \" ,\";\n        }\n    }\n    merge(jObj, node.attrsMap);\n    //add attrsMap as new children\n    if (isEmptyObject(jObj)) {\n        return isExist(node.val) ? node.val : \"\";\n    } else {\n        if (isExist(node.val)) {\n            if (!(typeof node.val === \"string\" && (node.val === \"\" || node.val === options.cdataPositionChar))) {\n                jObj += \"\\\"\" + options.textNodeName + \"\\\" : \" + stringval(node.val);\n            }\n        }\n    }\n    //add value\n    if (jObj[jObj.length - 1] === \",\") {\n        jObj = jObj.substr(0, jObj.length - 2);\n    }\n    return jObj + \"}\";\n};\n\nfunction stringval(v) {\n    if (v === true || v === false || !isNaN(v)) {\n        return v;\n    } else {\n        return \"\\\"\" + v + \"\\\"\";\n    }\n}\n\nfunction indentate(options, level) {\n    return options.indentBy.repeat(level);\n}\n\nmodule.exports = {convertToJsonString};\n","const {isEmptyObject, merge, isExist} = require(\"./util\");\n\nconst convertToJson = function(node, options) {\n    const jObj = {};\n\n    if ((!node.child || isEmptyObject(node.child)) && (!node.attrsMap || isEmptyObject(node.attrsMap))) {\n        return isExist(node.val) ? node.val : \"\";\n    } else {\n        if (isExist(node.val)) {\n            if (!(typeof node.val === \"string\" && (node.val === \"\" || node.val === options.cdataPositionChar))) {\n                jObj[options.textNodeName] = node.val;\n            }\n        }\n    }\n\n    merge(jObj, node.attrsMap);\n\n    for (let tagname of  Object.keys(node.child)) {\n        if (node.child[tagname] && node.child[tagname].length > 1) {\n            jObj[tagname] = [];\n            for (let tag of Object.keys(node.child[tagname])) {\n                jObj[tagname].push(convertToJson(node.child[tagname][tag], options));\n            }\n        } else {\n            jObj[tagname] = convertToJson(node.child[tagname][0], options);\n        }\n    }\n\n    //add value\n    return jObj;\n};\n\nmodule.exports = {convertToJson};\n","const char = (a) => String.fromCharCode(a);\n\nconst chars = {\n    nilChar: char(254),\n    missingChar: char(200),\n    nilPremitive: char(176),\n    missingPremitive: char(201),\n    emptyChar: char(177),\n    emptyValue: char(178),\n    boundryChar: char(186),\n    arrayEnd: char(197),\n    objStart: char(198),\n    arrStart: char(199)\n};\n\nconst charsArr = [\n    chars.nilChar,\n    chars.nilPremitive,\n    chars.missingChar,\n    chars.missingPremitive,\n    chars.boundryChar,\n    chars.emptyChar,\n    chars.arrayEnd,\n    chars.objStart,\n    chars.arrStart\n];\n\nconst _e = (node, e_schema, options) => {\n    if (typeof e_schema === \"string\") {//premitive\n        if (node && node[0] && node[0].val !== undefined) {\n            return getValue(node[0].val, e_schema);\n        } else {\n            return getValue(node, e_schema);\n        }\n    } else {\n        const hasValidData = hasData(node);\n        if (hasValidData === true) {\n            let str = \"\";\n            if (Array.isArray(e_schema)) {\n                //attributes can't be repeated. hence check in children tags only\n                str += chars.arrStart;\n                const itemSchema = e_schema[0];\n                //var itemSchemaType = itemSchema;\n                if (typeof itemSchema === \"string\") {\n                    for (let item of node) {\n                        const r = getValue(item.val, itemSchema);\n                        str = processValue(str, r);\n                    }\n                } else {\n                    for (let item of node) {\n                        const r = _e(item, itemSchema, options);\n                        str = processValue(str, r);\n                    }\n                }\n                str += chars.arrayEnd;//indicates that next item is not array item\n            } else {//object\n                str += chars.objStart;\n                if (Array.isArray(node)) {\n                    node = node[0];\n                }\n                for (let key of Object.keys(e_schema)) {\n                    //a property defined in schema can be present either in attrsMap or children tags\n                    //options.textNodeName will not present in both maps, take it's value from val\n                    //options.attrNodeName will be present in attrsMap\n                    let r;\n                    if (!options.ignoreAttributes && node.attrsMap && node.attrsMap[key]) {\n                        r = _e(node.attrsMap[key], e_schema[key], options);\n                    } else if (key === options.textNodeName) {\n                        r = _e(node.val, e_schema[key], options);\n                    } else {\n                        r = _e(node.child[key], e_schema[key], options);\n                    }\n                    str = processValue(str, r);\n                }\n            }\n            return str;\n        } else {\n            return hasValidData;\n        }\n    }\n};\n\nconst getValue = (a/*, type*/) => {\n    switch (a) {\n        case undefined:\n            return chars.missingPremitive;\n        case null:\n            return chars.nilPremitive;\n        case \"\":\n            return chars.emptyValue;\n        default:\n            return a;\n    }\n};\n\nconst processValue = (str, r) => {\n    if (!isAppChar(r[0]) && !isAppChar(str[str.length - 1])) {\n        str += chars.boundryChar;\n    }\n    return str + r;\n};\n\nconst isAppChar = (ch) => {\n    return charsArr.indexOf(ch) !== -1;\n};\n\nconst hasData = (jObj) => {\n    if (jObj === undefined) {\n        return chars.missingChar;\n    } else if (jObj === null) {\n        return chars.nilChar;\n    } else if (jObj.child && Object.keys(jObj.child).length === 0 && (!jObj.attrsMap || Object.keys(jObj.attrsMap).length === 0)) {\n        return chars.emptyChar;\n    } else {\n        return true;\n    }\n};\n\nconst {defaultOptions} = require(\"./x2j\");\nconst convertToNimn = (node, e_schema, options) => {\n    options = Object.assign({}, defaultOptions, options);\n    return _e(node, e_schema, options);\n};\n\nmodule.exports = {convertToNimn};\n","const {getTraversalObj} = require(\"./x2j\");\nconst {convertToNimn} = require(\"./nimn-data\");\nconst {validate} = require(\"./validator\");\nconst {Parser: j2xParser, isAttribute} = require(\"./j2x\");\nconst {defaultOptions} = require(\"./x2j\");\nconst {convertToJson} = require(\"./n2j\");\nconst {convertToJsonString} = require(\"./n2j-str\");\n\nconst parseToNimn = (xmlData, schema, options) => convertToNimn(getTraversalObj(xmlData, options), schema, options);\n\nconst parse = (xmlData, options) => {\n    options = Object.assign({}, defaultOptions, options);\n    return convertToJson(getTraversalObj(xmlData, options), options);\n};\n\nmodule.exports = {\n    parse,\n    parseToNimn,\n    convertToJson,\n    convertToJsonString,\n    convertToNimn,\n    getTraversalObj,\n    validate,\n    isAttribute,\n    j2xParser\n};\n","const getAllMatches = (string, regex) => {\n    const matches = [];\n    let match;\n    while ((match = regex.exec(string)) !== null) {\n        matches.push([...match]);\n    }\n    return matches;\n};\n\n/**\n * Copy all the properties of a into b.\n * @param {*} target\n * @param {*} source\n */\nconst merge = (target, source) => {\n    if (source) {\n        for (let key of Object.keys(source)) {\n            target[key] = source[key];\n        }\n    }\n    return target;\n};\n\nconst isEmptyObject = (obj) => Object.keys(obj).length === 0;\nconst isExist = (v) => typeof v !== \"undefined\";\n\nconst doesMatch = (string, regex) => {\n    const match = regex.exec(string);\n    return !(match === null || !isExist(match));\n};\n\nconst doesNotMatch = (string, regex) => !doesMatch(string, regex);\n\nconst getValue = (v) => isExist(v) ? v : \"\";\n\n// const fakeCall = function(a) {return a;};\n// const fakeCallNoReturn = function() {};\nmodule.exports = {\n    getValue,\n    merge,\n    isEmptyObject,\n    isExist,\n    doesMatch,\n    doesNotMatch,\n    getAllMatches\n};\n","const util = require(\"./util\");\n\nconst defaultOptions = {\n    allowBooleanAttributes: false         //A tag can have attributes without any value\n};\n\nconst buildOptions = (options) => {\n    if (!options) {\n        options = {};\n    }\n    const props = [\"allowBooleanAttributes\"];\n    for (let i of props) {\n        if (options[props[i]] === undefined) {\n            options[props[i]] = defaultOptions[props[i]];\n        }\n    }\n    return options;\n};\n\n//const tagsPattern = new RegExp(\"<\\\\/?([\\\\w:\\\\-_\\.]+)\\\\s*\\/?>\",\"g\");\nconst validate = (xmlData, options) => {\n    options = buildOptions(options);\n\n    //xmlData = xmlData.replace(/(\\r\\n|\\n|\\r)/gm,\"\");//make it single line\n    //xmlData = xmlData.replace(/(^\\s*<\\?xml.*?\\?>)/g,\"\");//Remove XML starting tag\n    //xmlData = xmlData.replace(/(<!DOCTYPE[\\s\\w\\\"\\.\\/\\-\\:]+(\\[.*\\])*\\s*>)/g,\"\");//Remove DOCTYPE\n\n    const tags = [];\n    let tagFound = false;\n    for (let i = 0; i < xmlData.length; i++) {\n\n        if (xmlData[i] === \"<\") {//starting of tag\n            //read until you reach to '>' avoiding any '>' in attribute value\n            i++;\n            if (xmlData[i] === \"?\") {\n                i = readPI(xmlData, ++i);\n                if (i.err) {\n                    return i;\n                }\n            } else if (xmlData[i] === \"!\") {\n                i = readCommentAndCDATA(xmlData, i);\n                continue;\n            } else {\n                let closingTag = false;\n                if (xmlData[i] === \"/\") {//closing tag\n                    closingTag = true;\n                    i++;\n                }\n                //read tagname\n                let tagName = \"\";\n                for (; i < xmlData.length &&\n                       xmlData[i] !== \">\" &&\n                       xmlData[i] !== \" \" &&\n                       xmlData[i] !== \"\\t\"; i++) {\n\n                    tagName += xmlData[i];\n                }\n                tagName = tagName.trim();\n                //console.log(tagName);\n\n                if (tagName[tagName.length - 1] === \"/\") {//self closing tag without attributes\n                    tagName = tagName.substring(0, tagName.length - 1);\n                    continue;\n                }\n                if (!validateTagName(tagName)) {\n                    return {err: {code: \"InvalidTag\", msg: \"Tag \" + tagName + \" is an invalid name.\"}};\n                }\n\n                const result = readAttributeStr(xmlData, i);\n                if (result === false) {\n                    return {err: {code: \"InvalidAttr\", msg: \"Attributes for \" + tagName + \" have open quote\"}};\n                }\n                let attrStr = result.value;\n                i = result.index;\n\n                if (attrStr[attrStr.length - 1] === \"/\") {//self closing tag\n                    attrStr = attrStr.substring(0, attrStr.length - 1);\n                    const isValid = validateAttributeString(attrStr, options);\n                    if (isValid === true) {\n                        tagFound = true;\n                        continue;\n                    } else {\n                        return isValid;\n                    }\n                } else if (closingTag) {\n                    if (attrStr.trim().length > 0) {\n                        return {err: {code: \"InvalidTag\", msg: \"closing tag \" + tagName + \" can't have attributes or invalid starting.\"}};\n                    } else {\n                        const otg = tags.pop();\n                        if (tagName !== otg) {\n                            return {err: {code: \"InvalidTag\", msg: \"closing tag \" + otg + \" is expected inplace of \" + tagName + \".\"}};\n                        }\n                    }\n                } else {\n                    const isValid = validateAttributeString(attrStr, options);\n                    if (isValid !== true) {\n                        return isValid;\n                    }\n                    tags.push(tagName);\n                    tagFound = true;\n                }\n\n                //skip tag text value\n                //It may include comments and CDATA value\n                for (i++; i < xmlData.length; i++) {\n                    if (xmlData[i] === \"<\") {\n                        if (xmlData[i + 1] === \"!\") {//comment or CADATA\n                            i++;\n                            i = readCommentAndCDATA(xmlData, i);\n                            continue;\n                        } else {\n                            break;\n                        }\n                    }\n                }//end of reading tag text value\n                if (xmlData[i] === \"<\") {\n                    i--;\n                }\n            }\n        } else {\n            if (xmlData[i] === \" \" || xmlData[i] === \"\\t\" || xmlData[i] === \"\\n\" || xmlData[i] === \"\\r\") {\n                continue;\n            }\n            return {err: {code: \"InvalidChar\", msg: \"char \" + xmlData[i] + \" is not expected .\"}};\n        }\n    }\n\n    if (!tagFound) {\n        return {err: {code: \"InvalidXml\", msg: \"Start tag expected.\"}};\n    } else if (tags.length > 0) {\n        return {err: {code: \"InvalidXml\", msg: \"Invalid \" + JSON.stringify(tags, null, 4).replace(/\\r?\\n/g, \"\") + \" found.\"}};\n    }\n\n    return true;\n};\n\n/**\n * Read Processing insstructions and skip\n * @param {*} xmlData\n * @param {*} i\n */\nfunction readPI(xmlData, i) {\n    const start = i;\n    for (; i < xmlData.length; i++) {\n        if (xmlData[i] === \"?\" || xmlData[i] === \" \") { //tagName\n            const tagName = xmlData.substr(start, i - start);\n            if (i > 5 && tagName === \"xml\") {\n                return {err: {code: \"InvalidXml\", msg: \"XML declaration allowed only at the start of the document.\"}};\n            } else if (xmlData[i] === \"?\" && xmlData[i + 1] === \">\") {\n                //check if valid attribute string\n                i++;\n                break;\n            } else {\n                continue;\n            }\n        }\n    }\n    return i;\n}\n\nfunction readCommentAndCDATA(xmlData, i) {\n    if (xmlData.length > i + 5 && xmlData[i + 1] === \"-\" && xmlData[i + 2] === \"-\") {//comment\n        for (i += 3; i < xmlData.length; i++) {\n            if (xmlData[i] === \"-\" && xmlData[i + 1] === \"-\" && xmlData[i + 2] === \">\") {\n                i += 2;\n                break;\n            }\n        }\n    } else if (xmlData.length > i + 8 &&\n               xmlData[i + 1] === \"D\" &&\n               xmlData[i + 2] === \"O\" &&\n               xmlData[i + 3] === \"C\" &&\n               xmlData[i + 4] === \"T\" &&\n               xmlData[i + 5] === \"Y\" &&\n               xmlData[i + 6] === \"P\" &&\n               xmlData[i + 7] === \"E\") {\n        let angleBracketsCount = 1;\n        for (i += 8; i < xmlData.length; i++) {\n            if (xmlData[i] === \"<\") {angleBracketsCount++;}\n            else if (xmlData[i] === \">\") {\n                angleBracketsCount--;\n                if (angleBracketsCount === 0) {\n                    break;\n                }\n            }\n        }\n    } else if (xmlData.length > i + 9 &&\n               xmlData[i + 1] === \"[\" &&\n               xmlData[i + 2] === \"C\" &&\n               xmlData[i + 3] === \"D\" &&\n               xmlData[i + 4] === \"A\" &&\n               xmlData[i + 5] === \"T\" &&\n               xmlData[i + 6] === \"A\" &&\n               xmlData[i + 7] === \"[\") {\n\n        for (i += 8; i < xmlData.length; i++) {\n            if (xmlData[i] === \"]\" && xmlData[i + 1] === \"]\" && xmlData[i + 2] === \">\") {\n                i += 2;\n                break;\n            }\n        }\n    }\n\n    return i;\n}\n\nconst doubleQuote = \"\\\"\";\nconst singleQuote = \"'\";\n\n/**\n * Keep reading xmlData until '<' is found outside the attribute value.\n * @param {string} xmlData\n * @param {number} i\n */\nfunction readAttributeStr(xmlData, i) {\n    let attrStr = \"\";\n    let startChar = \"\";\n    for (; i < xmlData.length; i++) {\n        if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\n            if (startChar === \"\") {\n                startChar = xmlData[i];\n            } else if (startChar !== xmlData[i]) {\n                //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa\n                continue;\n            } else {\n                startChar = \"\";\n            }\n        } else if (xmlData[i] === \">\") {\n            if (startChar === \"\") {\n                break;\n            }\n        }\n        attrStr += xmlData[i];\n    }\n    if (startChar !== \"\") {\n        return false;\n    }\n\n    return {value: attrStr, index: i};\n}\n\n/**\n * Select all the attributes whether valid or invalid.\n */\nconst validAttrStrRegxp = new RegExp(\"(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*(['\\\"])(([\\\\s\\\\S])*?)\\\\5)?\", \"g\");\n\n//attr, =\"sd\", a=\"amit's\", a=\"sd\"b=\"saf\", ab  cd=\"\"\n\nfunction validateAttributeString(attrStr, options) {\n    //console.log(\"start:\"+attrStr+\":end\");\n\n    //if(attrStr.trim().length === 0) return true; //empty string\n\n    const matches = util.getAllMatches(attrStr, validAttrStrRegxp);\n    const attrNames = [];\n\n    for (let match of matches) {\n        //console.log(matches[i]);\n\n        if (match[1].length === 0) {//nospace before attribute name: a=\"sd\"b=\"saf\"\n            return {err: {code: \"InvalidAttr\", msg: \"attribute \" + match[2] + \" has no space in starting.\"}};\n        } else if (match[3] === undefined && !options.allowBooleanAttributes) {//independent attribute: ab\n            return {err: {code: \"InvalidAttr\", msg: \"boolean attribute \" + match[2] + \" is not allowed.\"}};\n        }\n        /* else if(matches[i][6] === undefined){//attribute without value: ab=\n                    return { err: { code:\"InvalidAttr\",msg:\"attribute \" + matches[i][2] + \" has no value assigned.\"}};\n                } */\n        const attrName = match[2];\n        if (!validateAttrName(attrName)) {\n            return {err: {code: \"InvalidAttr\", msg: \"attribute \" + attrName + \" is an invalid name.\"}};\n        }\n        if (!attrNames.hasOwnProperty(attrName)) {//check for duplicate attribute.\n            attrNames[attrName] = 1;\n        } else {\n            return {err: {code: \"InvalidAttr\", msg: \"attribute \" + attrName + \" is repeated.\"}};\n        }\n    }\n\n    return true;\n\n}\n\nconst validAttrRegxp = /^[_a-zA-Z][\\w\\-.:]*$/;\n\nfunction validateAttrName(attrName) {\n    return util.doesMatch(attrName, validAttrRegxp);\n}\n\n//const startsWithXML = new RegExp(\"^[Xx][Mm][Ll]\");\nconst startsWith = /^([a-zA-Z]|_)[\\w.\\-_:]*/;\n\nfunction validateTagName(tagname) {\n    /*if(util.doesMatch(tagname,startsWithXML)) return false;\n    else*/\n    return !util.doesNotMatch(tagname, startsWith);\n}\n\nmodule.exports = {validate};\n","const util = require(\"./util\");\nconst {XmlNode} = require(\"./xml-node\");\nconst TagType = {\"OPENING\": 1, \"CLOSING\": 2, \"SELF\": 3, \"CDATA\": 4};\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\n//treat cdata as a tag\n\nconst defaultOptions = {\n    attributeNamePrefix: \"@_\",\n    attrNodeName: false,\n    textNodeName: \"#text\",\n    ignoreAttributes: true,\n    ignoreNameSpace: false,\n    allowBooleanAttributes: false,         //a tag can have attributes without any value\n    //ignoreRootElement : false,\n    parseNodeValue: true,\n    parseAttributeValue: false,\n    arrayMode: false,\n    trimValues: true,                                //Trim string values of tag and attributes\n    cdataTagName: false,\n    cdataPositionChar: \"\\\\c\",\n    tagValueProcessor: function(a) {return a;},\n    attrValueProcessor: function(a) {return a;}\n    //decodeStrict: false,\n};\n\nconst getTraversalObj = (xmlData, options) => {\n    //options = buildOptions(options);\n    options = Object.assign({}, defaultOptions, options);\n    //xmlData = xmlData.replace(/\\r?\\n/g, \" \");//make it single line\n    xmlData = xmlData.replace(/<!--[\\s\\S]*?-->/g, \"\");//Remove  comments\n\n    const xmlObj = new XmlNode(\"!xml\");\n    let currentNode = xmlObj;\n\n    const tagsRegx = /<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|(([\\w:\\-._]*:)?([\\w:\\-._]+))([^>]*)>|((\\/)(([\\w:\\-._]*:)?([\\w:\\-._]+))>))([^<]*)/g;\n    let tag = tagsRegx.exec(xmlData);\n    let nextTag = tagsRegx.exec(xmlData);\n    while (tag) {\n        const tagType = checkForTagType(tag);\n\n        if (tagType === TagType.CLOSING) {\n            //add parsed data to parent node\n            if (currentNode.parent && tag[14]) {\n                currentNode.parent.val = util.getValue(currentNode.parent.val) + \"\" + processTagValue(tag[14], options);\n            }\n\n            currentNode = currentNode.parent;\n        } else if (tagType === TagType.CDATA) {\n            if (options.cdataTagName) {\n                //add cdata node\n                const childNode = new XmlNode(options.cdataTagName, currentNode, tag[3]);\n                childNode.attrsMap = buildAttributesMap(tag[8], options);\n                currentNode.addChild(childNode);\n                //for backtracking\n                currentNode.val = util.getValue(currentNode.val) + options.cdataPositionChar;\n                //add rest value to parent node\n                if (tag[14]) {\n                    currentNode.val += processTagValue(tag[14], options);\n                }\n            } else {\n                currentNode.val = (currentNode.val || \"\") + (tag[3] || \"\") + processTagValue(tag[14], options);\n            }\n        } else if (tagType === TagType.SELF) {\n            const childNode = new XmlNode(options.ignoreNameSpace ? tag[7] : tag[5], currentNode, \"\");\n            if (tag[8] && tag[8].length > 1) {\n                tag[8] = tag[8].substr(0, tag[8].length - 1);\n            }\n            childNode.attrsMap = buildAttributesMap(tag[8], options);\n            currentNode.addChild(childNode);\n        } else {//TagType.OPENING\n            const childNode = new XmlNode(options.ignoreNameSpace ? tag[7] : tag[5], currentNode, processTagValue(tag[14], options));\n            childNode.attrsMap = buildAttributesMap(tag[8], options);\n            currentNode.addChild(childNode);\n            currentNode = childNode;\n        }\n\n        tag = nextTag;\n        nextTag = tagsRegx.exec(xmlData);\n    }\n\n    return xmlObj;\n};\n\nfunction processTagValue(val, options) {\n    if (val) {\n        if (options.trimValues) {\n            val = val.trim();\n        }\n        val = options.tagValueProcessor(val);\n        val = parseValue(val, options.parseNodeValue);\n    }\n\n    return val;\n}\n\nfunction checkForTagType(match) {\n    if (match[4] === \"]]>\") {\n        return TagType.CDATA;\n    } else if (match[10] === \"/\") {\n        return TagType.CLOSING;\n    } else if (typeof match[8] !== \"undefined\" && match[8].substr(match[8].length - 1) === \"/\") {\n        return TagType.SELF;\n    } else {\n        return TagType.OPENING;\n    }\n}\n\nfunction resolveNameSpace(tagname, options) {\n    if (options.ignoreNameSpace) {\n        const tags = tagname.split(\":\");\n        const prefix = tagname.charAt(0) === \"/\" ? \"/\" : \"\";\n        if (tags[0] === \"xmlns\") {\n            return \"\";\n        }\n        if (tags.length === 2) {\n            tagname = prefix + tags[1];\n        }\n    }\n    return tagname;\n}\n\nfunction parseValue(val, shouldParse) {\n    if (shouldParse && typeof val === \"string\") {\n        if (val.trim() === \"\" || isNaN(val)) {\n            val = val === \"true\" ? true : val === \"false\" ? false : val;\n        } else {\n            if (val.indexOf(\".\") !== -1) {\n                val = parseFloat(val);\n            } else {\n                val = parseInt(val, 10);\n            }\n        }\n        return val;\n    }\n    if (util.isExist(val)) {\n        return val;\n    }\n    return \"\";\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp(\"([^\\\\s=]+)\\\\s*(=\\\\s*(['\\\"])(.*?)\\\\3)?\", \"g\");\n\nfunction buildAttributesMap(attrStr, options) {\n    if (!options.ignoreAttributes && typeof attrStr === \"string\") {\n        attrStr = attrStr.replace(/\\r?\\n/g, \" \");\n        //attrStr = attrStr || attrStr.trim();\n\n        const matches = util.getAllMatches(attrStr, attrsRegx);\n        const attrs = {};\n        for (let match of matches) {\n            const attrName = resolveNameSpace(match[1], options);\n            if (attrName.length) {\n                if (match[4] !== undefined) {\n                    if (options.trimValues) {\n                        match[4] = match[4].trim();\n                    }\n                    match[4] = options.attrValueProcessor(match[4]);\n                    attrs[options.attributeNamePrefix + attrName] = parseValue(match[4], options.parseAttributeValue);\n                } else if (options.allowBooleanAttributes) {\n                    attrs[options.attributeNamePrefix + attrName] = true;\n                }\n\n            }\n        }\n        if (!Object.keys(attrs).length) {\n            return;\n        }\n        if (options.attrNodeName) {\n            const attrCollection = {};\n            attrCollection[options.attrNodeName] = attrs;\n            return attrCollection;\n        }\n        return attrs;\n    }\n}\n\nmodule.exports = {\n    defaultOptions,\n    getTraversalObj\n};\n","class XmlNode {\n    constructor(tagname, parent, val) {\n        this.tagname = tagname;\n        this.parent = parent;\n\n        this.child = {}; //child tags\n        this.attrsMap = {}; //attributes map\n\n        this.val = val;//text only\n    }\n\n    addChild(child) {\n        if (this.child[child.tagname]) {//already presents\n            this.child[child.tagname].push(child);\n        } else {\n            this.child[child.tagname] = [child];\n        }\n    }\n}\n\nmodule.exports = {XmlNode};\n"],"sourceRoot":""}