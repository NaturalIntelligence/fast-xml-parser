{"version":3,"sources":["webpack/bootstrap","./src/j2x.js","./src/n2j-str.js","./src/n2j.js","./src/nimn-data.js","./src/parser.js","./src/util.js","./src/validator.js","./src/x2j.js","./src/xml-node.js"],"names":["require","isExist","buildOptions","defaultOptions","attributeNamePrefix","attrNodeName","textNodeName","ignoreAttributes","cdataTagName","cdataPositionChar","format","indentBy","supressEmptyNode","tagValueProcessor","a","attrValueProcessor","props","Parser","options","isAttribute","attrPrefixLen","length","isCDATA","replaceCDATAstr","replaceCDATAarr","indentate","tagEndChar","newLine","buildTextNode","buildEmptyTextNode","buildObjNode","buildEmptyObjNode","buildTextValNode","buildObjectNode","jObj","j2x","val","level","attrStr","Object","keys","key","attr","Array","isArray","item","result","attrKey","str","cdata","replace","join","v","repeat","name","startsWith","substr","module","exports","isEmptyObject","merge","convertToJsonString","node","_cToJsonStr","child","tagname","tag","attrsMap","stringval","isNaN","convertToJson","push","char","String","fromCharCode","chars","nilChar","missingChar","nilPremitive","missingPremitive","emptyChar","emptyValue","boundryChar","arrayEnd","objStart","arrStart","charsArr","_e","e_schema","undefined","getValue","hasValidData","hasData","itemSchema","r","processValue","isAppChar","ch","indexOf","convertToNimn","getTraversalObj","validate","j2xParser","parseToNimn","xmlData","schema","parse","getAllMatches","string","regex","matches","match","exec","target","source","obj","doesMatch","doesNotMatch","newOptions","i","allowBooleanAttributes","tags","tagFound","readPI","err","readCommentAndCDATA","closingTag","tagName","trim","substring","validateTagName","code","msg","readAttributeStr","value","index","isValid","validateAttributeString","otg","pop","JSON","stringify","start","angleBracketsCount","doubleQuote","singleQuote","startChar","validAttrStrRegxp","RegExp","attrNames","attrName","validateAttrName","hasOwnProperty","validAttrRegxp","XmlNode","TagType","ignoreNameSpace","parseNodeValue","parseAttributeValue","arrayMode","trimValues","xmlObj","currentNode","tagsRegx","nextTag","tagType","checkForTagType","CLOSING","parent","processTagValue","CDATA","childNode","buildAttributesMap","addChild","SELF","parseValue","OPENING","resolveNameSpace","split","prefix","charAt","shouldParse","parseFloat","parseInt","attrsRegx","attrs","attrCollection"],"mappings":"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","file":"./parser.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading wasm modules\n \tvar installedWasmModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// object with all compiled WebAssembly.Modules\n \t__webpack_require__.w = {};\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/parser.js\");\n","const {isExist, buildOptions} = require(\"./util\");\n\nconst defaultOptions = {\n    attributeNamePrefix: \"@_\",\n    attrNodeName: false,\n    textNodeName: \"#text\",\n    ignoreAttributes: true,\n    cdataTagName: false,\n    cdataPositionChar: \"\\\\c\",\n    format: false,\n    indentBy: \"  \",\n    supressEmptyNode: false,\n    tagValueProcessor: (a) => a,\n    attrValueProcessor: (a) => a\n};\n\nconst props = [\n    \"attributeNamePrefix\",\n    \"attrNodeName\",\n    \"textNodeName\",\n    \"ignoreAttributes\",\n    \"cdataTagName\",\n    \"cdataPositionChar\",\n    \"format\",\n    \"indentBy\",\n    \"supressEmptyNode\",\n    \"tagValueProcessor\",\n    \"attrValueProcessor\"\n];\n\nclass Parser {\n    constructor(options) {\n        this.options = buildOptions(options, defaultOptions, props);\n        if (this.options.ignoreAttributes || this.options.attrNodeName) {\n            this.isAttribute = function(/*a*/) { return false;};\n        } else {\n            this.attrPrefixLen = this.options.attributeNamePrefix.length;\n            this.isAttribute = isAttribute;\n        }\n        if (this.options.cdataTagName) {\n            this.isCDATA = isCDATA;\n        } else {\n            this.isCDATA = (/*a*/) => false;\n        }\n        this.replaceCDATAstr = replaceCDATAstr;\n        this.replaceCDATAarr = replaceCDATAarr;\n\n        if (this.options.format) {\n            this.indentate = indentate;\n            this.tagEndChar = \">\\n\";\n            this.newLine = \"\\n\";\n        } else {\n            this.indentate = () => \"\";\n            this.tagEndChar = \">\";\n            this.newLine = \"\";\n        }\n\n        if (this.options.supressEmptyNode) {\n            this.buildTextNode = buildEmptyTextNode;\n            this.buildObjNode = buildEmptyObjNode;\n        } else {\n            this.buildTextNode = buildTextValNode;\n            this.buildObjNode = buildObjectNode;\n        }\n\n        this.buildTextValNode = buildTextValNode;\n        this.buildObjectNode = buildObjectNode;\n    }\n\n    parse(jObj) {\n        return this.j2x(jObj, 0).val;\n    }\n\n    j2x(jObj, level) {\n        let attrStr = \"\";\n        let val = \"\";\n        for (let key of Object.keys(jObj)) {\n            if (!isExist(jObj[key])) {\n                // supress undefined node\n            }\n            else if (typeof jObj[key] !== \"object\") {//premitive type\n                const attr = this.isAttribute(key);\n                if (attr) {\n                    attrStr += \" \" + attr + \"=\\\"\" + this.options.attrValueProcessor(\"\" + jObj[key]) + \"\\\"\";\n                } else if (this.isCDATA(key)) {\n                    if (jObj[this.options.textNodeName]) {\n                        val += this.replaceCDATAstr(jObj[this.options.textNodeName], jObj[key]);\n                    } else {\n                        val += this.replaceCDATAstr(\"\", jObj[key]);\n                    }\n                } else {//tag value\n                    if (key === this.options.textNodeName) {\n                        if (jObj[this.options.cdataTagName]) {\n                            //value will added while processing cdata\n                        } else {\n                            val += this.options.tagValueProcessor(\"\" + jObj[key]);\n                        }\n                    } else {\n                        val += this.buildTextNode(jObj[key], key, \"\", level);\n                    }\n                }\n            } else if (Array.isArray(jObj[key])) {//repeated nodes\n                if (this.isCDATA(key)) {\n                    if (jObj[this.options.textNodeName]) {\n                        val += this.replaceCDATAarr(jObj[this.options.textNodeName], jObj[key]);\n                    } else {\n                        val += this.replaceCDATAarr(\"\", jObj[key]);\n                    }\n                } else {//nested nodes\n                    for (let item of jObj[key]) {\n                        if (!isExist(item)) {\n                            // supress undefined node\n                        }\n                        else if (typeof item === \"object\") {\n                            const result = this.j2x(item, level + 1);\n                            val += this.buildObjNode(result.val, key, result.attrStr, level);\n                        } else {\n                            val += this.buildTextNode(item, key, \"\", level);\n                        }\n                    }\n                }\n            } else {\n                if (this.options.attrNodeName && key === this.options.attrNodeName) {\n                    for (let attrKey of Object.keys(jObj[key])) {\n                        attrStr += \" \" + attrKey + \"=\\\"\" + this.options.tagValueProcessor(\"\" + jObj[key][attrKey]) + \"\\\"\";\n                    }\n                } else {\n                    const result = this.j2x(jObj[key], level + 1);\n                    val += this.buildObjNode(result.val, key, result.attrStr, level);\n                }\n            }\n        }\n        return {attrStr: attrStr, val: val};\n    }\n}\n\nfunction replaceCDATAstr(str, cdata) {\n    str = this.options.tagValueProcessor(\"\" + str);\n    if (this.options.cdataPositionChar === \"\" || str === \"\") {\n        return str + \"<![CDATA[\" + cdata + \"]]>\";\n    } else {\n        return str.replace(this.options.cdataPositionChar, \"<![CDATA[\" + cdata + \"]]>\");\n    }\n}\n\nfunction replaceCDATAarr(str, cdata) {\n    str = this.options.tagValueProcessor(\"\" + str);\n    if (this.options.cdataPositionChar === \"\" || str === \"\") {\n        return str + \"<![CDATA[\" + cdata.join(\"]]><![CDATA[\") + \"]]>\";\n    } else {\n        for (const v of Object.keys(cdata)) {\n            str = str.replace(this.options.cdataPositionChar, \"<![CDATA[\" + cdata[v] + \"]]>\");\n        }\n        return str;\n    }\n}\n\nfunction buildObjectNode(val, key, attrStr, level) {\n    return this.indentate(level)\n           + \"<\" + key + attrStr\n           + this.tagEndChar\n           + val\n           //+ this.newLine\n           + this.indentate(level)\n           + \"</\" + key + this.tagEndChar;\n}\n\nfunction buildEmptyObjNode(val, key, attrStr, level) {\n    if (val !== \"\") {\n        return this.buildObjectNode(val, key, attrStr, level);\n    } else {\n        return this.indentate(level)\n               + \"<\" + key + attrStr\n               + \"/\"\n               + this.tagEndChar;\n        //+ this.newLine\n    }\n}\n\nfunction buildTextValNode(val, key, attrStr, level) {\n    return this.indentate(level) + \"<\" + key + attrStr + \">\" + this.options.tagValueProcessor(\"\" + val) + \"</\" + key + this.tagEndChar;\n}\n\nfunction buildEmptyTextNode(val, key, attrStr, level) {\n    if (val !== \"\") {\n        return this.buildTextValNode(val, key, attrStr, level);\n    } else {\n        return this.indentate(level) + \"<\" + key + attrStr + \"/\" + this.tagEndChar;\n    }\n}\n\nfunction indentate(level) {\n    return this.options.indentBy.repeat(level);\n}\n\nfunction isAttribute(name/*, options*/) {\n    if (name.startsWith(this.options.attributeNamePrefix)) {\n        return name.substr(this.attrPrefixLen);\n    } else {\n        return false;\n    }\n}\n\nfunction isCDATA(name) {\n    return name === this.options.cdataTagName;\n}\n\n//formatting\n//indentation\n//\\n after each closing or self closing tag\n\nmodule.exports = {Parser, isAttribute};\n","\"use strict\";\n\nconst {buildOptions, isEmptyObject, isExist, merge} = require(\"./util\");\nconst {defaultOptions, props} = require(\"./x2j\");\n\n//TODO: do it later\nconst convertToJsonString = function(node, options) {\n    options = buildOptions(options,defaultOptions,props);\n\n    options.indentBy = options.indentBy || \"\";\n    return _cToJsonStr(node, options, 0);\n};\n\nconst _cToJsonStr = function(node, options, level) {\n    let jObj = \"{\";\n\n    //traver through all the children\n    for (let tagname of Object.keys(node.child)) {\n        if (node.child[tagname] && node.child[tagname].length > 1) {\n            jObj += \"\\\"\" + tagname + \"\\\" : [ \";\n            for (let tag of Object.keys(node.child[tagname])) {\n                jObj += _cToJsonStr(node.child[tagname][tag], options) + \" , \";\n            }\n            jObj = jObj.substr(0, jObj.length - 1) + \" ] \"; //remove extra comma in last\n        } else {\n            jObj += \"\\\"\" + tagname + \"\\\" : \" + _cToJsonStr(node.child[tagname][0], options) + \" ,\";\n        }\n    }\n    merge(jObj, node.attrsMap);\n    //add attrsMap as new children\n    if (isEmptyObject(jObj)) {\n        return isExist(node.val) ? node.val : \"\";\n    } else {\n        if (isExist(node.val)) {\n            if (!(typeof node.val === \"string\" && (node.val === \"\" || node.val === options.cdataPositionChar))) {\n                jObj += \"\\\"\" + options.textNodeName + \"\\\" : \" + stringval(node.val);\n            }\n        }\n    }\n    //add value\n    if (jObj[jObj.length - 1] === \",\") {\n        jObj = jObj.substr(0, jObj.length - 2);\n    }\n    return jObj + \"}\";\n};\n\nfunction stringval(v) {\n    if (v === true || v === false || !isNaN(v)) {\n        return v;\n    } else {\n        return \"\\\"\" + v + \"\\\"\";\n    }\n}\n\nfunction indentate(options, level) {\n    return options.indentBy.repeat(level);\n}\n\nmodule.exports = {convertToJsonString};\n","const {isEmptyObject, merge, isExist} = require(\"./util\");\n\nconst convertToJson = function(node, options) {\n    const jObj = {};\n\n    if ((!node.child || isEmptyObject(node.child)) && (!node.attrsMap || isEmptyObject(node.attrsMap))) {\n        return isExist(node.val) ? node.val : \"\";\n    } else {\n        if (isExist(node.val)) {\n            if (!(typeof node.val === \"string\" && (node.val === \"\" || node.val === options.cdataPositionChar))) {\n                jObj[options.textNodeName] = node.val;\n            }\n        }\n    }\n\n    merge(jObj, node.attrsMap);\n\n    for (let tagname of  Object.keys(node.child)) {\n        if (node.child[tagname] && node.child[tagname].length > 1) {\n            jObj[tagname] = [];\n            for (let tag of Object.keys(node.child[tagname])) {\n                jObj[tagname].push(convertToJson(node.child[tagname][tag], options));\n            }\n        } else {\n            jObj[tagname] = convertToJson(node.child[tagname][0], options);\n        }\n    }\n\n    //add value\n    return jObj;\n};\n\nmodule.exports = {convertToJson};\n","const char = (a) => String.fromCharCode(a);\n\nconst chars = {\n    nilChar: char(254),\n    missingChar: char(200),\n    nilPremitive: char(176),\n    missingPremitive: char(201),\n    emptyChar: char(177),\n    emptyValue: char(178),\n    boundryChar: char(186),\n    arrayEnd: char(197),\n    objStart: char(198),\n    arrStart: char(199)\n};\n\nconst charsArr = [\n    chars.nilChar,\n    chars.nilPremitive,\n    chars.missingChar,\n    chars.missingPremitive,\n    chars.boundryChar,\n    chars.emptyChar,\n    chars.arrayEnd,\n    chars.objStart,\n    chars.arrStart\n];\n\nconst _e = (node, e_schema, options) => {\n    if (typeof e_schema === \"string\") {//premitive\n        if (node && node[0] && node[0].val !== undefined) {\n            return getValue(node[0].val, e_schema);\n        } else {\n            return getValue(node, e_schema);\n        }\n    } else {\n        const hasValidData = hasData(node);\n        if (hasValidData === true) {\n            let str = \"\";\n            if (Array.isArray(e_schema)) {\n                //attributes can't be repeated. hence check in children tags only\n                str += chars.arrStart;\n                const itemSchema = e_schema[0];\n                //var itemSchemaType = itemSchema;\n                if (typeof itemSchema === \"string\") {\n                    for (let item of node) {\n                        const r = getValue(item.val, itemSchema);\n                        str = processValue(str, r);\n                    }\n                } else {\n                    for (let item of node) {\n                        const r = _e(item, itemSchema, options);\n                        str = processValue(str, r);\n                    }\n                }\n                str += chars.arrayEnd;//indicates that next item is not array item\n            } else {//object\n                str += chars.objStart;\n                if (Array.isArray(node)) {\n                    node = node[0];\n                }\n                for (let key of Object.keys(e_schema)) {\n                    //a property defined in schema can be present either in attrsMap or children tags\n                    //options.textNodeName will not present in both maps, take it's value from val\n                    //options.attrNodeName will be present in attrsMap\n                    let r;\n                    if (!options.ignoreAttributes && node.attrsMap && node.attrsMap[key]) {\n                        r = _e(node.attrsMap[key], e_schema[key], options);\n                    } else if (key === options.textNodeName) {\n                        r = _e(node.val, e_schema[key], options);\n                    } else {\n                        r = _e(node.child[key], e_schema[key], options);\n                    }\n                    str = processValue(str, r);\n                }\n            }\n            return str;\n        } else {\n            return hasValidData;\n        }\n    }\n};\n\nconst getValue = (a/*, type*/) => {\n    switch (a) {\n        case undefined:\n            return chars.missingPremitive;\n        case null:\n            return chars.nilPremitive;\n        case \"\":\n            return chars.emptyValue;\n        default:\n            return a;\n    }\n};\n\nconst processValue = (str, r) => {\n    if (!isAppChar(r[0]) && !isAppChar(str[str.length - 1])) {\n        str += chars.boundryChar;\n    }\n    return str + r;\n};\n\nconst isAppChar = (ch) => {\n    return charsArr.indexOf(ch) !== -1;\n};\n\nconst hasData = (jObj) => {\n    if (jObj === undefined) {\n        return chars.missingChar;\n    } else if (jObj === null) {\n        return chars.nilChar;\n    } else if (jObj.child && Object.keys(jObj.child).length === 0 && (!jObj.attrsMap || Object.keys(jObj.attrsMap).length === 0)) {\n        return chars.emptyChar;\n    } else {\n        return true;\n    }\n};\n\nconst {defaultOptions, props} = require(\"./x2j\");\nconst {buildOptions} = require(\"./util\");\nconst convertToNimn = (node, e_schema, options) => {\n    options = buildOptions(options,defaultOptions,props);\n    return _e(node, e_schema, options);\n};\n\nmodule.exports = {convertToNimn};\n","const {getTraversalObj} = require(\"./x2j\");\nconst {convertToNimn} = require(\"./nimn-data\");\nconst {validate} = require(\"./validator\");\nconst {Parser: j2xParser, isAttribute} = require(\"./j2x\");\nconst {defaultOptions,props} = require(\"./x2j\");\nconst {convertToJson} = require(\"./n2j\");\nconst {convertToJsonString} = require(\"./n2j-str\");\nconst {buildOptions} = require(\"./util\");\n\nconst parseToNimn = (xmlData, schema, options) => convertToNimn(getTraversalObj(xmlData, options), schema, options);\n\nconst parse = (xmlData, options) => {\n    options = buildOptions(options,defaultOptions,props);\n    return convertToJson(getTraversalObj(xmlData, options), options);\n};\n\nmodule.exports = {\n    parse,\n    parseToNimn,\n    convertToJson,\n    convertToJsonString,\n    convertToNimn,\n    getTraversalObj,\n    validate,\n    isAttribute,\n    j2xParser\n};\n","const getAllMatches = (string, regex) => {\n    const matches = [];\n    let match;\n    while ((match = regex.exec(string)) !== null) {\n        matches.push([...match]);\n    }\n    return matches;\n};\n\n/**\n * Copy all the properties of a into b.\n * @param {*} target\n * @param {*} source\n */\nconst merge = (target, source) => {\n    if (source) {\n        for (let key of Object.keys(source)) {\n            target[key] = source[key];\n        }\n    }\n    return target;\n};\n\nconst isEmptyObject = (obj) => Object.keys(obj).length === 0;\nconst isExist = (v) => typeof v !== \"undefined\";\n\nconst doesMatch = (string, regex) => {\n    const match = regex.exec(string);\n    return !(match === null || !isExist(match));\n};\n\nconst doesNotMatch = (string, regex) => !doesMatch(string, regex);\n\nconst getValue = (v) => isExist(v) ? v : \"\";\n\n// const fakeCall = function(a) {return a;};\n// const fakeCallNoReturn = function() {};\nconst buildOptions = function(options,defaultOptions,props) {\n    var newOptions = {};\n    if (!options) {\n        options = {};\n    }\n\n    for (let i = 0; i < props.length; i++) {\n        if ( options[props[i]] !== undefined) {\n            newOptions[props[i]] = options[props[i]];\n        }else{\n            newOptions[props[i]] = defaultOptions[props[i]];\n        }\n    }\n    return newOptions;\n};\n\nmodule.exports = {\n    buildOptions,\n    getValue,\n    merge,\n    isEmptyObject,\n    isExist,\n    doesMatch,\n    doesNotMatch,\n    getAllMatches\n};\n","const {buildOptions, getAllMatches, doesMatch, doesNotMatch} = require(\"./util\");\n\nconst defaultOptions = {\n    allowBooleanAttributes: false         //A tag can have attributes without any value\n};\n\nconst props = [\"allowBooleanAttributes\"];\n\n//const tagsPattern = new RegExp(\"<\\\\/?([\\\\w:\\\\-_\\.]+)\\\\s*\\/?>\",\"g\");\nconst validate = function(xmlData, options) {\n    options = buildOptions(options, defaultOptions, props);\n\n    //xmlData = xmlData.replace(/(\\r\\n|\\n|\\r)/gm,\"\");//make it single line\n    //xmlData = xmlData.replace(/(^\\s*<\\?xml.*?\\?>)/g,\"\");//Remove XML starting tag\n    //xmlData = xmlData.replace(/(<!DOCTYPE[\\s\\w\\\"\\.\\/\\-\\:]+(\\[.*\\])*\\s*>)/g,\"\");//Remove DOCTYPE\n\n    const tags = [];\n    let tagFound = false;\n    for (let i = 0; i < xmlData.length; i++) {\n\n        if (xmlData[i] === \"<\") {//starting of tag\n            //read until you reach to '>' avoiding any '>' in attribute value\n            i++;\n            if (xmlData[i] === \"?\") {\n                i = readPI(xmlData, ++i);\n                if (i.err) {\n                    return i;\n                }\n            } else if (xmlData[i] === \"!\") {\n                i = readCommentAndCDATA(xmlData, i);\n                continue;\n            } else {\n                let closingTag = false;\n                if (xmlData[i] === \"/\") {//closing tag\n                    closingTag = true;\n                    i++;\n                }\n                //read tagname\n                let tagName = \"\";\n                for (; i < xmlData.length &&\n                       xmlData[i] !== \">\" &&\n                       xmlData[i] !== \" \" &&\n                       xmlData[i] !== \"\\t\"; i++) {\n\n                    tagName += xmlData[i];\n                }\n                tagName = tagName.trim();\n                //console.log(tagName);\n\n                if (tagName[tagName.length - 1] === \"/\") {//self closing tag without attributes\n                    tagName = tagName.substring(0, tagName.length - 1);\n                    continue;\n                }\n                if (!validateTagName(tagName)) {\n                    return {err: {code: \"InvalidTag\", msg: \"Tag \" + tagName + \" is an invalid name.\"}};\n                }\n\n                const result = readAttributeStr(xmlData, i);\n                if (result === false) {\n                    return {err: {code: \"InvalidAttr\", msg: \"Attributes for \" + tagName + \" have open quote\"}};\n                }\n                let attrStr = result.value;\n                i = result.index;\n\n                if (attrStr[attrStr.length - 1] === \"/\") {//self closing tag\n                    attrStr = attrStr.substring(0, attrStr.length - 1);\n                    const isValid = validateAttributeString(attrStr, options);\n                    if (isValid === true) {\n                        tagFound = true;\n                        continue;\n                    } else {\n                        return isValid;\n                    }\n                } else if (closingTag) {\n                    if (attrStr.trim().length > 0) {\n                        return {err: {code: \"InvalidTag\", msg: \"closing tag \" + tagName + \" can't have attributes or invalid starting.\"}};\n                    } else {\n                        const otg = tags.pop();\n                        if (tagName !== otg) {\n                            return {err: {code: \"InvalidTag\", msg: \"closing tag \" + otg + \" is expected inplace of \" + tagName + \".\"}};\n                        }\n                    }\n                } else {\n                    const isValid = validateAttributeString(attrStr, options);\n                    if (isValid !== true) {\n                        return isValid;\n                    }\n                    tags.push(tagName);\n                    tagFound = true;\n                }\n\n                //skip tag text value\n                //It may include comments and CDATA value\n                for (i++; i < xmlData.length; i++) {\n                    if (xmlData[i] === \"<\") {\n                        if (xmlData[i + 1] === \"!\") {//comment or CADATA\n                            i++;\n                            i = readCommentAndCDATA(xmlData, i);\n                            continue;\n                        } else {\n                            break;\n                        }\n                    }\n                }//end of reading tag text value\n                if (xmlData[i] === \"<\") {\n                    i--;\n                }\n            }\n        } else {\n            if (xmlData[i] === \" \" || xmlData[i] === \"\\t\" || xmlData[i] === \"\\n\" || xmlData[i] === \"\\r\") {\n                continue;\n            }\n            return {err: {code: \"InvalidChar\", msg: \"char \" + xmlData[i] + \" is not expected .\"}};\n        }\n    }\n\n    if (!tagFound) {\n        return {err: {code: \"InvalidXml\", msg: \"Start tag expected.\"}};\n    } else if (tags.length > 0) {\n        return {err: {code: \"InvalidXml\", msg: \"Invalid \" + JSON.stringify(tags, null, 4).replace(/\\r?\\n/g, \"\") + \" found.\"}};\n    }\n\n    return true;\n};\n\n/**\n * Read Processing insstructions and skip\n * @param {*} xmlData\n * @param {*} i\n */\nfunction readPI(xmlData, i) {\n    const start = i;\n    for (; i < xmlData.length; i++) {\n        if (xmlData[i] === \"?\" || xmlData[i] === \" \") { //tagName\n            const tagName = xmlData.substr(start, i - start);\n            if (i > 5 && tagName === \"xml\") {\n                return {err: {code: \"InvalidXml\", msg: \"XML declaration allowed only at the start of the document.\"}};\n            } else if (xmlData[i] === \"?\" && xmlData[i + 1] === \">\") {\n                //check if valid attribute string\n                i++;\n                break;\n            } else {\n                continue;\n            }\n        }\n    }\n    return i;\n}\n\nfunction readCommentAndCDATA(xmlData, i) {\n    if (xmlData.length > i + 5 && xmlData[i + 1] === \"-\" && xmlData[i + 2] === \"-\") {//comment\n        for (i += 3; i < xmlData.length; i++) {\n            if (xmlData[i] === \"-\" && xmlData[i + 1] === \"-\" && xmlData[i + 2] === \">\") {\n                i += 2;\n                break;\n            }\n        }\n    } else if (xmlData.length > i + 8 &&\n               xmlData[i + 1] === \"D\" &&\n               xmlData[i + 2] === \"O\" &&\n               xmlData[i + 3] === \"C\" &&\n               xmlData[i + 4] === \"T\" &&\n               xmlData[i + 5] === \"Y\" &&\n               xmlData[i + 6] === \"P\" &&\n               xmlData[i + 7] === \"E\") {\n        let angleBracketsCount = 1;\n        for (i += 8; i < xmlData.length; i++) {\n            if (xmlData[i] === \"<\") {angleBracketsCount++;}\n            else if (xmlData[i] === \">\") {\n                angleBracketsCount--;\n                if (angleBracketsCount === 0) {\n                    break;\n                }\n            }\n        }\n    } else if (xmlData.length > i + 9 &&\n               xmlData[i + 1] === \"[\" &&\n               xmlData[i + 2] === \"C\" &&\n               xmlData[i + 3] === \"D\" &&\n               xmlData[i + 4] === \"A\" &&\n               xmlData[i + 5] === \"T\" &&\n               xmlData[i + 6] === \"A\" &&\n               xmlData[i + 7] === \"[\") {\n\n        for (i += 8; i < xmlData.length; i++) {\n            if (xmlData[i] === \"]\" && xmlData[i + 1] === \"]\" && xmlData[i + 2] === \">\") {\n                i += 2;\n                break;\n            }\n        }\n    }\n\n    return i;\n}\n\nconst doubleQuote = \"\\\"\";\nconst singleQuote = \"'\";\n\n/**\n * Keep reading xmlData until '<' is found outside the attribute value.\n * @param {string} xmlData\n * @param {number} i\n */\nfunction readAttributeStr(xmlData, i) {\n    let attrStr = \"\";\n    let startChar = \"\";\n    for (; i < xmlData.length; i++) {\n        if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\n            if (startChar === \"\") {\n                startChar = xmlData[i];\n            } else if (startChar !== xmlData[i]) {\n                //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa\n                continue;\n            } else {\n                startChar = \"\";\n            }\n        } else if (xmlData[i] === \">\") {\n            if (startChar === \"\") {\n                break;\n            }\n        }\n        attrStr += xmlData[i];\n    }\n    if (startChar !== \"\") {\n        return false;\n    }\n\n    return {value: attrStr, index: i};\n}\n\n/**\n * Select all the attributes whether valid or invalid.\n */\nconst validAttrStrRegxp = new RegExp(\"(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*(['\\\"])(([\\\\s\\\\S])*?)\\\\5)?\", \"g\");\n\n//attr, =\"sd\", a=\"amit's\", a=\"sd\"b=\"saf\", ab  cd=\"\"\n\nfunction validateAttributeString(attrStr, options) {\n    //console.log(\"start:\"+attrStr+\":end\");\n\n    //if(attrStr.trim().length === 0) return true; //empty string\n\n    const matches = getAllMatches(attrStr, validAttrStrRegxp);\n    const attrNames = [];\n\n    for (let match of matches) {\n        //console.log(matches[i]);\n\n        if (match[1].length === 0) {//nospace before attribute name: a=\"sd\"b=\"saf\"\n            return {err: {code: \"InvalidAttr\", msg: \"attribute \" + match[2] + \" has no space in starting.\"}};\n        } else if (match[3] === undefined && !options.allowBooleanAttributes) {//independent attribute: ab\n            return {err: {code: \"InvalidAttr\", msg: \"boolean attribute \" + match[2] + \" is not allowed.\"}};\n        }\n        /* else if(matches[i][6] === undefined){//attribute without value: ab=\n                    return { err: { code:\"InvalidAttr\",msg:\"attribute \" + matches[i][2] + \" has no value assigned.\"}};\n                } */\n        const attrName = match[2];\n        if (!validateAttrName(attrName)) {\n            return {err: {code: \"InvalidAttr\", msg: \"attribute \" + attrName + \" is an invalid name.\"}};\n        }\n        if (!attrNames.hasOwnProperty(attrName)) {//check for duplicate attribute.\n            attrNames[attrName] = 1;\n        } else {\n            return {err: {code: \"InvalidAttr\", msg: \"attribute \" + attrName + \" is repeated.\"}};\n        }\n    }\n\n    return true;\n\n}\n\nconst validAttrRegxp = /^[_a-zA-Z][\\w\\-.:]*$/;\n\nfunction validateAttrName(attrName) {\n    return doesMatch(attrName, validAttrRegxp);\n}\n\n//const startsWithXML = new RegExp(\"^[Xx][Mm][Ll]\");\nconst startsWith = /^([a-zA-Z]|_)[\\w.\\-_:]*/;\n\nfunction validateTagName(tagname) {\n    /*if(doesMatch(tagname,startsWithXML)) return false;\n    else*/\n    return !doesNotMatch(tagname, startsWith);\n}\n\nmodule.exports = {validate};\n","const {buildOptions, getValue, isExist, getAllMatches} = require(\"./util\");\nconst {XmlNode} = require(\"./xml-node\");\nconst TagType = {\"OPENING\": 1, \"CLOSING\": 2, \"SELF\": 3, \"CDATA\": 4};\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\n//treat cdata as a tag\n\nconst defaultOptions = {\n    attributeNamePrefix: \"@_\",\n    attrNodeName: false,\n    textNodeName: \"#text\",\n    ignoreAttributes: true,\n    ignoreNameSpace: false,\n    allowBooleanAttributes: false,         //a tag can have attributes without any value\n    //ignoreRootElement : false,\n    parseNodeValue: true,\n    parseAttributeValue: false,\n    arrayMode: false,\n    trimValues: true,                                //Trim string values of tag and attributes\n    cdataTagName: false,\n    cdataPositionChar: \"\\\\c\",\n    tagValueProcessor: (a) => a,\n    attrValueProcessor: (a) => a\n    //decodeStrict: false,\n};\n\nexports.defaultOptions = defaultOptions;\nconst props = [\"attributeNamePrefix\", \"attrNodeName\", \"textNodeName\", \"ignoreAttributes\", \"ignoreNameSpace\", \"allowBooleanAttributes\", \"parseNodeValue\", \"parseAttributeValue\", \"arrayMode\", \"trimValues\", \"cdataTagName\", \"cdataPositionChar\", \"tagValueProcessor\", \"attrValueProcessor\"];\n\nconst getTraversalObj = function(xmlData, options) {\n    //options = buildOptions(options);\n    options = buildOptions(options,defaultOptions,props);\n    //xmlData = xmlData.replace(/\\r?\\n/g, \" \");//make it single line\n    xmlData = xmlData.replace(/<!--[\\s\\S]*?-->/g, \"\");//Remove  comments\n\n    const xmlObj = new XmlNode(\"!xml\");\n    let currentNode = xmlObj;\n\n    const tagsRegx = /<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|(([\\w:\\-._]*:)?([\\w:\\-._]+))([^>]*)>|((\\/)(([\\w:\\-._]*:)?([\\w:\\-._]+))>))([^<]*)/g;\n    let tag = tagsRegx.exec(xmlData);\n    let nextTag = tagsRegx.exec(xmlData);\n    while (tag) {\n        const tagType = checkForTagType(tag);\n\n        if (tagType === TagType.CLOSING) {\n            //add parsed data to parent node\n            if (currentNode.parent && tag[14]) {\n                currentNode.parent.val = getValue(currentNode.parent.val) + \"\" + processTagValue(tag[14], options);\n            }\n\n            currentNode = currentNode.parent;\n        } else if (tagType === TagType.CDATA) {\n            if (options.cdataTagName) {\n                //add cdata node\n                const childNode = new XmlNode(options.cdataTagName, currentNode, tag[3]);\n                childNode.attrsMap = buildAttributesMap(tag[8], options);\n                currentNode.addChild(childNode);\n                //for backtracking\n                currentNode.val = getValue(currentNode.val) + options.cdataPositionChar;\n                //add rest value to parent node\n                if (tag[14]) {\n                    currentNode.val += processTagValue(tag[14], options);\n                }\n            } else {\n                currentNode.val = (currentNode.val || \"\") + (tag[3] || \"\") + processTagValue(tag[14], options);\n            }\n        } else if (tagType === TagType.SELF) {\n            const childNode = new XmlNode(options.ignoreNameSpace ? tag[7] : tag[5], currentNode, \"\");\n            if (tag[8] && tag[8].length > 1) {\n                tag[8] = tag[8].substr(0, tag[8].length - 1);\n            }\n            childNode.attrsMap = buildAttributesMap(tag[8], options);\n            currentNode.addChild(childNode);\n        } else {//TagType.OPENING\n            const childNode = new XmlNode(options.ignoreNameSpace ? tag[7] : tag[5], currentNode, processTagValue(tag[14], options));\n            childNode.attrsMap = buildAttributesMap(tag[8], options);\n            currentNode.addChild(childNode);\n            currentNode = childNode;\n        }\n\n        tag = nextTag;\n        nextTag = tagsRegx.exec(xmlData);\n    }\n\n    return xmlObj;\n};\n\nfunction processTagValue(val, options) {\n    if (val) {\n        if (options.trimValues) {\n            val = val.trim();\n        }\n        val = options.tagValueProcessor(val);\n        val = parseValue(val, options.parseNodeValue);\n    }\n\n    return val;\n}\n\nfunction checkForTagType(match) {\n    if (match[4] === \"]]>\") {\n        return TagType.CDATA;\n    } else if (match[10] === \"/\") {\n        return TagType.CLOSING;\n    } else if (typeof match[8] !== \"undefined\" && match[8].substr(match[8].length - 1) === \"/\") {\n        return TagType.SELF;\n    } else {\n        return TagType.OPENING;\n    }\n}\n\nfunction resolveNameSpace(tagname, options) {\n    if (options.ignoreNameSpace) {\n        const tags = tagname.split(\":\");\n        const prefix = tagname.charAt(0) === \"/\" ? \"/\" : \"\";\n        if (tags[0] === \"xmlns\") {\n            return \"\";\n        }\n        if (tags.length === 2) {\n            tagname = prefix + tags[1];\n        }\n    }\n    return tagname;\n}\n\nfunction parseValue(val, shouldParse) {\n    if (shouldParse && typeof val === \"string\") {\n        if (val.trim() === \"\" || isNaN(val)) {\n            val = val === \"true\" ? true : val === \"false\" ? false : val;\n        } else {\n            if (val.indexOf(\".\") !== -1) {\n                val = parseFloat(val);\n            } else {\n                val = parseInt(val, 10);\n            }\n        }\n        return val;\n    }\n    if (isExist(val)) {\n        return val;\n    }\n    return \"\";\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp(\"([^\\\\s=]+)\\\\s*(=\\\\s*(['\\\"])(.*?)\\\\3)?\", \"g\");\n\nfunction buildAttributesMap(attrStr, options) {\n    if (!options.ignoreAttributes && typeof attrStr === \"string\") {\n        attrStr = attrStr.replace(/\\r?\\n/g, \" \");\n        //attrStr = attrStr || attrStr.trim();\n\n        const matches = getAllMatches(attrStr, attrsRegx);\n        const attrs = {};\n        for (let match of matches) {\n            const attrName = resolveNameSpace(match[1], options);\n            if (attrName.length) {\n                if (match[4] !== undefined) {\n                    if (options.trimValues) {\n                        match[4] = match[4].trim();\n                    }\n                    match[4] = options.attrValueProcessor(match[4]);\n                    attrs[options.attributeNamePrefix + attrName] = parseValue(match[4], options.parseAttributeValue);\n                } else if (options.allowBooleanAttributes) {\n                    attrs[options.attributeNamePrefix + attrName] = true;\n                }\n\n            }\n        }\n        if (!Object.keys(attrs).length) {\n            return;\n        }\n        if (options.attrNodeName) {\n            const attrCollection = {};\n            attrCollection[options.attrNodeName] = attrs;\n            return attrCollection;\n        }\n        return attrs;\n    }\n}\n\nmodule.exports = {\n    props,\n    defaultOptions,\n    getTraversalObj\n};\n","class XmlNode {\n    constructor(tagname, parent, val) {\n        this.tagname = tagname;\n        this.parent = parent;\n\n        this.child = {}; //child tags\n        this.attrsMap = {}; //attributes map\n\n        this.val = val;//text only\n    }\n\n    addChild(child) {\n        if (this.child[child.tagname]) {//already presents\n            this.child[child.tagname].push(child);\n        } else {\n            this.child[child.tagname] = [child];\n        }\n    }\n}\n\nmodule.exports = {XmlNode};\n"],"sourceRoot":""}